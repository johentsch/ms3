


<!DOCTYPE html>

<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>ms3.parse &#8212; ms3 0.5.3.post0.dev88+g764fcd4.dirty documentation</title>
    <link rel="stylesheet" type="text/css" href="../../_static/pygments.css" />
    <link rel="stylesheet" type="text/css" href="../../_static/cloud.css" />
    <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Noticia+Text:400,i,b,bi|Open+Sans:400,i,b,bi|Roboto+Mono:400,i,b,bi&amp;display=swap" type="text/css" />
    
    <script data-url_root="../../" id="documentation_options" src="../../_static/documentation_options.js"></script>
    <script src="../../_static/jquery.js"></script>
    <script src="../../_static/underscore.js"></script>
    <script src="../../_static/_sphinx_javascript_frameworks_compat.js"></script>
    <script src="../../_static/doctools.js"></script>

    
    
     
        <script src="../../_static/jquery.cookie.js"></script>
    

    
     
        <script src="../../_static/cloud.base.js"></script>
    

    
     
        <script src="../../_static/cloud.js"></script>
    

    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" /> 
        <meta name="viewport" content="width=device-width, initial-scale=1">
  </head><body>
    <div class="relbar-top">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
    <li><a href="../../index.html">ms3 0.5.3.post0.dev88+g764fcd4.dirty documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" accesskey="U">Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ms3.parse</a></li> 
      </ul>
    </div>
    </div>
  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <h1>Source code for ms3.parse</h1><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="kn">import</span> <span class="n">Literal</span><span class="p">,</span> <span class="n">Collection</span><span class="p">,</span> <span class="n">Generator</span><span class="p">,</span> <span class="n">Tuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">,</span> <span class="n">Dict</span><span class="p">,</span> <span class="n">Optional</span><span class="p">,</span> <span class="n">List</span><span class="p">,</span> <span class="n">Iterator</span>

<span class="kn">import</span> <span class="nn">io</span>
<span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>
<span class="kn">import</span> <span class="nn">traceback</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="kn">import</span> <span class="n">Counter</span><span class="p">,</span> <span class="n">defaultdict</span>

<span class="kn">import</span> <span class="nn">pandas</span> <span class="k">as</span> <span class="nn">pd</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">git</span> <span class="kn">import</span> <span class="n">Repo</span><span class="p">,</span> <span class="n">InvalidGitRepositoryError</span>
<span class="kn">from</span> <span class="nn">gitdb.exc</span> <span class="kn">import</span> <span class="n">BadName</span>

<span class="kn">from</span> <span class="nn">.corpus</span> <span class="kn">import</span> <span class="n">Corpus</span>
<span class="kn">from</span> <span class="nn">.annotations</span> <span class="kn">import</span> <span class="n">Annotations</span>
<span class="kn">from</span> <span class="nn">.logger</span> <span class="kn">import</span> <span class="n">LoggedClass</span><span class="p">,</span> <span class="n">get_logger</span>
<span class="kn">from</span> <span class="nn">.piece</span> <span class="kn">import</span> <span class="n">Piece</span>
<span class="kn">from</span> <span class="nn">.score</span> <span class="kn">import</span> <span class="n">Score</span>
<span class="kn">from</span> <span class="nn">._typing</span> <span class="kn">import</span> <span class="n">FileDict</span><span class="p">,</span> <span class="n">FileList</span><span class="p">,</span> <span class="n">CorpusFnameTuple</span><span class="p">,</span> <span class="n">ScoreFacets</span><span class="p">,</span> <span class="n">FileDataframeTupleMaybe</span><span class="p">,</span> <span class="n">FacetArguments</span><span class="p">,</span> <span class="n">FileParsedTuple</span><span class="p">,</span> <span class="n">FileDataframeTuple</span><span class="p">,</span> <span class="n">ScoreFacet</span><span class="p">,</span> <span class="n">AnnotationsFacet</span>
<span class="kn">from</span> <span class="nn">.utils</span> <span class="kn">import</span> <span class="n">column_order</span><span class="p">,</span> <span class="n">get_musescore</span><span class="p">,</span> <span class="n">group_id_tuples</span><span class="p">,</span> <span class="n">iter_selection</span><span class="p">,</span> <span class="n">get_first_level_corpora</span><span class="p">,</span> <span class="n">join_tsvs</span><span class="p">,</span> <span class="n">load_tsv</span><span class="p">,</span> <span class="n">make_continuous_offset_series</span><span class="p">,</span> \
    <span class="n">make_id_tuples</span><span class="p">,</span> <span class="n">make_playthrough2mc</span><span class="p">,</span> <span class="n">METADATA_COLUMN_ORDER</span><span class="p">,</span> <span class="n">metadata2series</span><span class="p">,</span> <span class="n">parse_ignored_warnings_file</span><span class="p">,</span> <span class="n">pretty_dict</span><span class="p">,</span> <span class="n">resolve_dir</span><span class="p">,</span> \
    <span class="n">update_labels_cfg</span><span class="p">,</span> <span class="n">write_tsv</span><span class="p">,</span> <span class="n">available_views2str</span><span class="p">,</span> <span class="n">path2parent_corpus</span><span class="p">,</span> <span class="n">resolve_paths_argument</span><span class="p">,</span> <span class="n">enforce_fname_index_for_metadata</span>
<span class="kn">from</span> <span class="nn">.view</span> <span class="kn">import</span> <span class="n">View</span><span class="p">,</span> <span class="n">create_view_from_parameters</span><span class="p">,</span> <span class="n">DefaultView</span>


<div class="viewcode-block" id="Parse"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse">[docs]</a><span class="k">class</span> <span class="nc">Parse</span><span class="p">(</span><span class="n">LoggedClass</span><span class="p">):</span>
    <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Class for creating one or several :class:`~.corpus.Corpus` objects and performing actions on all of them.</span>
<span class="sd">    &quot;&quot;&quot;</span>

<div class="viewcode-block" id="Parse.__init__"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.__init__">[docs]</a>    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> 
                 <span class="n">directory</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Collection</span><span class="p">[</span><span class="nb">str</span><span class="p">]]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">recursive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                 <span class="n">only_metadata_fnames</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                 <span class="n">include_convertible</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                 <span class="n">include_tsv</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span> 
                 <span class="n">exclude_review</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                 <span class="n">file_re</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">folder_re</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> 
                 <span class="n">exclude_re</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">paths</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Collection</span><span class="p">[</span><span class="nb">str</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">labels_cfg</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span>
                 <span class="n">ms</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">logger_cfg</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Initialize a Parse object and try to create corpora if directories and/or file paths are specified.</span>

<span class="sd">        Args:</span>
<span class="sd">            directory: Path to scan for corpora.</span>
<span class="sd">            recursive: Pass False if you don&#39;t want to scan ``directory`` for subcorpora, but force making it a corpus instead.</span>
<span class="sd">            only_metadata_fnames:</span>
<span class="sd">                The default view excludes piece names that are not listed in the corpus&#39; metadata.tsv file (e.g. when none was found).</span>
<span class="sd">                Pass False to include all pieces regardless. This might be needed when setting ``recursive`` to False.</span>
<span class="sd">            include_convertible:</span>
<span class="sd">                The default view excludes scores that would need conversion to MuseScore format prior to parsing.</span>
<span class="sd">                Pass True to include convertible scores in .musicxml, .midi, .cap or any other format that MuseScore 3 can open.</span>
<span class="sd">                For on-the-fly conversion, however, the parameter ``ms`` needs to be set.</span>
<span class="sd">            include_tsv: The default view includes TSV files. Pass False to disregard them and parse only scores.</span>
<span class="sd">            exclude_review:</span>
<span class="sd">                The default view excludes files and folders whose name contains &#39;review&#39;.</span>
<span class="sd">                Pass False to include these as well.</span>
<span class="sd">            file_re: Pass a regular expression if you want to create a view filtering out all files that do not contain it.</span>
<span class="sd">            folder_re: Pass a regular expression if you want to create a view filtering out all folders that do not contain it.</span>
<span class="sd">            exclude_re: Pass a regular expression if you want to create a view filtering out all files or folders that contain it.</span>
<span class="sd">            paths:</span>
<span class="sd">                If ``directory`` is specified, the file names of these paths are used to create a filtering view excluding all other files.</span>
<span class="sd">                Otherwise, all paths are expected to be part of the same parent corpus which will be inferred from the first path by looking for the first parent directory that</span>
<span class="sd">                either contains a &#39;metadata.tsv&#39; file or is a git. This parameter is deprecated and ``file_re`` should be used instead.</span>
<span class="sd">            labels_cfg: Pass a configuration dict to detect only certain labels or change their output format.</span>
<span class="sd">            ms:</span>
<span class="sd">                If you pass the path to your local MuseScore 3 installation, ms3 will attempt to parse musicXML, MuseScore 2,</span>
<span class="sd">                and other formats by temporarily converting them. If you&#39;re using the standard path, you may try &#39;auto&#39;, or &#39;win&#39; for</span>
<span class="sd">                Windows, &#39;mac&#39; for MacOS, or &#39;mscore&#39; for Linux. In case you do not pass the &#39;file_re&#39; and the MuseScore executable is</span>
<span class="sd">                detected, all convertible files are automatically selected, otherwise only those that can be parsed without conversion.</span>
<span class="sd">            **logger_cfg: Keyword arguments for changing the logger configuration. E.g. ``level=&#39;d&#39;`` to see all debug messages.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="s1">&#39;level&#39;</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">logger_cfg</span> <span class="ow">or</span> <span class="p">(</span><span class="n">logger_cfg</span><span class="p">[</span><span class="s1">&#39;level&#39;</span><span class="p">]</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">):</span>
            <span class="n">logger_cfg</span><span class="p">[</span><span class="s1">&#39;level&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;w&#39;</span>
        <span class="nb">super</span><span class="p">()</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">subclass</span><span class="o">=</span><span class="s1">&#39;Parse&#39;</span><span class="p">,</span> <span class="n">logger_cfg</span><span class="o">=</span><span class="n">logger_cfg</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">corpus_paths</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="sd">&quot;&quot;&quot;{corpus_name -&gt; path} dictionary with each corpus&#39;s base directory. Generally speaking, each corpus path is expected to contain a ``metadata.tsv`` and, maybe, to be a git.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">corpus_objects</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Corpus</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="sd">&quot;&quot;&quot;{corpus_name -&gt; Corpus} dictionary with one object per :attr:`corpus_path &lt;corpus_paths&gt;`.</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_ms</span> <span class="o">=</span> <span class="n">get_musescore</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">initial_view</span> <span class="o">=</span> <span class="n">create_view_from_parameters</span><span class="p">(</span><span class="n">only_metadata_fnames</span><span class="o">=</span><span class="n">only_metadata_fnames</span><span class="p">,</span>
                                                   <span class="n">include_convertible</span><span class="o">=</span><span class="n">include_convertible</span><span class="p">,</span>
                                                   <span class="n">include_tsv</span><span class="o">=</span><span class="n">include_tsv</span><span class="p">,</span>
                                                   <span class="n">exclude_review</span><span class="o">=</span><span class="n">exclude_review</span><span class="p">,</span>
                                                   <span class="n">paths</span><span class="o">=</span><span class="n">paths</span><span class="p">,</span>
                                                   <span class="n">file_re</span><span class="o">=</span><span class="n">file_re</span><span class="p">,</span>
                                                   <span class="n">folder_re</span><span class="o">=</span><span class="n">folder_re</span><span class="p">,</span>
                                                   <span class="n">exclude_re</span><span class="o">=</span><span class="n">exclude_re</span><span class="p">,</span>
                                                   <span class="n">level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">getEffectiveLevel</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">initial_view</span>
        <span class="k">if</span> <span class="n">initial_view</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="s1">&#39;default&#39;</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="p">[</span><span class="s1">&#39;default&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">DefaultView</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">getEffectiveLevel</span><span class="p">())</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="n">View</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">getEffectiveLevel</span><span class="p">())</span>
        <span class="c1">#</span>
        <span class="c1"># self._ignored_warnings = defaultdict(list)</span>
        <span class="c1"># &quot;&quot;&quot;:obj:`collections.defaultdict`</span>
        <span class="c1"># {&#39;logger_name&#39; -&gt; [(message_id), ...]} This dictionary stores the warnings to be ignored</span>
        <span class="c1"># upon loading them from an IGNORED_WARNINGS file.</span>
        <span class="c1"># &quot;&quot;&quot;</span>
        <span class="c1">#</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels_cfg</span> <span class="o">=</span> <span class="p">{</span>
            <span class="s1">&#39;staff&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;voice&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;harmony_layer&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
            <span class="s1">&#39;positioning&#39;</span><span class="p">:</span> <span class="kc">False</span><span class="p">,</span>
            <span class="s1">&#39;decode&#39;</span><span class="p">:</span> <span class="kc">True</span><span class="p">,</span>
            <span class="s1">&#39;column_name&#39;</span><span class="p">:</span> <span class="s1">&#39;label&#39;</span><span class="p">,</span>
            <span class="s1">&#39;color_format&#39;</span><span class="p">:</span> <span class="kc">None</span><span class="p">,</span>
        <span class="p">}</span>
        <span class="sd">&quot;&quot;&quot;:obj:`dict`</span>
<span class="sd">        Configuration dictionary to determine the output format of :py:attr:`~.score.Score.labels` and</span>
<span class="sd">        :py:attr:`~.score.Score.expanded` tables. The dictonary is passed to :py:attr:`~.score.Score` upon parsing.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels_cfg</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">update_labels_cfg</span><span class="p">(</span><span class="n">labels_cfg</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">))</span>

        <span class="k">if</span> <span class="n">directory</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
                <span class="n">directory</span> <span class="o">=</span> <span class="p">[</span><span class="n">directory</span><span class="p">]</span>
            <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">directory</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_dir</span><span class="p">(</span><span class="n">directory</span><span class="o">=</span><span class="n">d</span><span class="p">,</span> <span class="n">recursive</span><span class="o">=</span><span class="n">recursive</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">paths</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_files</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span></div>
    <span class="c1">#%%%%%%%%%%%%%%%%%%%%%%%%%%%%% END of __init__() %%%%%%%%%%%%%%%%%%%%%%%%%%%%%#</span>
    <span class="c1">#%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%#</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">ms</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Path or command of the local MuseScore 3 installation if specified by the user and recognized.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_ms</span>

    <span class="nd">@ms</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">ms</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">ms</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_ms</span> <span class="o">=</span> <span class="n">get_musescore</span><span class="p">(</span><span class="n">ms</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_detected</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Number of detected files aggregated from all :class:`~.corpus.Corpus` objects without taking views into account. Excludes metadata files.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">corpus</span><span class="o">.</span><span class="n">n_detected</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_orphans</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Number of files that are always disregarded because they could not be attributed to any of the fnames.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">corpus</span><span class="o">.</span><span class="n">ix2orphan_file</span><span class="p">)</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_parsed</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Number of parsed files aggregated from all :class:`~.corpus.Corpus` objects without taking views into account. Excludes metadata files.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">corpus</span><span class="o">.</span><span class="n">n_parsed</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_parsed_scores</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Number of parsed scores aggregated from all :class:`~.corpus.Corpus` objects without taking views into account. Excludes metadata files.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">corpus</span><span class="o">.</span><span class="n">n_parsed_scores</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_parsed_tsvs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Number of parsed TSV files aggregated from all :class:`~.corpus.Corpus` objects without taking views into account. Excludes metadata files.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">corpus</span><span class="o">.</span><span class="n">n_parsed_tsvs</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_unparsed_scores</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Number of all detected but not yet parsed scores, aggregated from all :class:`~.corpus.Corpus` objects without taking views into account. Excludes metadata files.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">corpus</span><span class="o">.</span><span class="n">n_unparsed_scores</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">n_unparsed_tsvs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Number of all detected but not yet parsed TSV files, aggregated from all :class:`~.corpus.Corpus` objects without taking views into account. Excludes metadata files.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">corpus</span><span class="o">.</span><span class="n">n_unparsed_tsvs</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">)</span>


    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parsed_mscx</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Deprecated property. Replaced by :attr:`n_parsed_scores`&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Property has been renamed to n_parsed_scores.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">parsed_tsv</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Deprecated property. Replaced by :attr:`n_parsed_tsvs`&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Property has been renamed to n_parsed_tsvs.&quot;</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">View</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Retrieve the current View object. Shorthand for :meth:`get_view`.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_view</span><span class="p">()</span>

    <span class="nd">@view</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_view</span><span class="p">:</span> <span class="n">View</span><span class="p">):</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">new_view</span><span class="p">,</span> <span class="n">View</span><span class="p">):</span>
            <span class="k">return</span> <span class="ne">TypeError</span><span class="p">(</span><span class="s2">&quot;If you want to switch to an existing view, use its name like an attribute or &quot;</span>
                             <span class="s2">&quot;call _.switch_view().&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_view</span><span class="p">(</span><span class="n">new_view</span><span class="p">)</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">views</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Display a short description of the available views.&quot;&quot;&quot;</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">pretty_dict</span><span class="p">({</span><span class="s2">&quot;[active]&quot;</span> <span class="k">if</span> <span class="n">k</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">k</span><span class="p">:</span> <span class="n">v</span> <span class="k">for</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="o">.</span><span class="n">items</span><span class="p">()},</span> <span class="s2">&quot;view_name&quot;</span><span class="p">,</span> <span class="s2">&quot;Description&quot;</span><span class="p">))</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">view_name</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get the name of the active view.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_view</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>

    <span class="nd">@view_name</span><span class="o">.</span><span class="n">setter</span>
    <span class="k">def</span> <span class="nf">view_name</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">new_name</span><span class="p">):</span>
        <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_view</span><span class="p">()</span>
        <span class="n">view</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">new_name</span>

    <span class="nd">@property</span>
    <span class="k">def</span> <span class="nf">view_names</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">view</span><span class="o">.</span><span class="n">name</span> <span class="k">if</span> <span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="n">name</span> <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">view</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

<div class="viewcode-block" id="Parse.add_corpus"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.add_corpus">[docs]</a>    <span class="k">def</span> <span class="nf">add_corpus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                   <span class="n">directory</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                   <span class="n">corpus_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="o">**</span><span class="n">logger_cfg</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method creates a :class:`~.corpus.Corpus` object which scans the directory ``directory`` for parseable files.</span>
<span class="sd">        It inherits all :class:`Views &lt;.view.View&gt;` from the Parse object.</span>

<span class="sd">        Args:</span>
<span class="sd">            directory: Directory to scan for files.</span>
<span class="sd">            corpus_name:</span>
<span class="sd">                By default, the folder name of ``directory`` is used as name for this corpus. Pass a string to</span>
<span class="sd">                use a different identifier.</span>
<span class="sd">            **logger_cfg:</span>
<span class="sd">                Keyword arguments for configuring the logger of the new Corpus object. E.g. ``level=&#39;d&#39;`` to see all debug messages.</span>
<span class="sd">                Note that the logger is a child logger of this Parse object&#39;s logger and propagates, so it might filter debug messages.</span>
<span class="sd">                You can use _.change_logger_cfg(level=&#39;d&#39;) to change the level post hoc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">directory</span> <span class="o">=</span> <span class="n">resolve_dir</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">directory</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">directory</span><span class="si">}</span><span class="s2"> is not an existing directory.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">new_logger_cfg</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">logger_cfg</span><span class="p">)</span>
        <span class="n">new_logger_cfg</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">logger_cfg</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">corpus_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">corpus_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\/&quot;</span><span class="p">)</span>
        <span class="n">logger_cfg</span><span class="p">[</span><span class="s1">&#39;name&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">name</span> <span class="o">+</span> <span class="s1">&#39;.&#39;</span> <span class="o">+</span> <span class="n">corpus_name</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="s1">&#39;.&#39;</span><span class="p">,</span> <span class="s1">&#39;&#39;</span><span class="p">)</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="n">corpus</span> <span class="o">=</span> <span class="n">Corpus</span><span class="p">(</span><span class="n">directory</span><span class="o">=</span><span class="n">directory</span><span class="p">,</span> <span class="n">view</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">get_view</span><span class="p">(),</span> <span class="n">ms</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">ms</span><span class="p">,</span> <span class="o">**</span><span class="n">logger_cfg</span><span class="p">)</span>
        <span class="k">except</span> <span class="ne">AssertionError</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">directory</span><span class="si">}</span><span class="s2"> contains no parseable files.&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="n">corpus</span><span class="o">.</span><span class="n">set_view</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">view_name</span><span class="p">:</span> <span class="n">view</span> <span class="k">for</span> <span class="n">view_name</span><span class="p">,</span> <span class="n">view</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">view_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">})</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">corpus</span><span class="o">.</span><span class="n">files</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No parseable files detected in </span><span class="si">{</span><span class="n">directory</span><span class="si">}</span><span class="s2">. Skipping...&quot;</span><span class="p">)</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">corpus_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">corpus_name</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">basename</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span><span class="o">.</span><span class="n">strip</span><span class="p">(</span><span class="sa">r</span><span class="s1">&#39;\/&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">corpus_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus_paths</span><span class="p">:</span>
            <span class="n">existing_path</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus_paths</span><span class="p">[</span><span class="n">corpus_name</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">existing_path</span> <span class="o">==</span> <span class="n">directory</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Corpus &#39;</span><span class="si">{</span><span class="n">corpus_name</span><span class="si">}</span><span class="s2">&#39; had already been present and was overwritten, i.e., reset.&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Corpus &#39;</span><span class="si">{</span><span class="n">corpus_name</span><span class="si">}</span><span class="s2">&#39; had already been present for the path </span><span class="si">{</span><span class="n">existing_path</span><span class="si">}</span><span class="s2"> and &quot;</span>
                                    <span class="sa">f</span><span class="s2">&quot;was replaced by </span><span class="si">{</span><span class="n">directory</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corpus_paths</span><span class="p">[</span><span class="n">corpus_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">directory</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">corpus_objects</span><span class="p">[</span><span class="n">corpus_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">corpus</span></div>
        <span class="c1"># convertible = self.ms is not None</span>
        <span class="c1"># if file_re is None:</span>
        <span class="c1">#     file_re = Score._make_extension_regex(tsv=True, convertible=convertible)</span>
        <span class="c1"># if exclude_re is None:</span>
        <span class="c1">#     exclude_re = r&#39;(^(\.|_|concatenated_)|_reviewed)&#39;</span>
        <span class="c1"># directory = resolve_dir(directory)</span>
        <span class="c1"># self.last_scanned_dir = directory</span>
        <span class="c1"># if key is None:</span>
        <span class="c1">#     key = os.path.basename(directory)</span>
        <span class="c1"># if key not in self.files:</span>
        <span class="c1">#     self.logger.debug(f&quot;Adding {directory} as new corpus with key &#39;{key}&#39;.&quot;)</span>
        <span class="c1">#     self.files[key] = []</span>
        <span class="c1">#     self.corpus_paths[key] = resolve_dir(directory)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     self.logger.info(f&quot;Adding {directory} to existing corpus with key &#39;{key}&#39;.&quot;)</span>
        <span class="c1">#</span>
        <span class="c1"># top_level_folders, top_level_files = first_level_files_and_subdirs(directory)</span>
        <span class="c1"># self.logger.debug(f&quot;Top level folders: {top_level_folders}\nTop level files: {top_level_files}&quot;)</span>
        <span class="c1">#</span>
        <span class="c1"># added_ids = []</span>
        <span class="c1">#</span>
        <span class="c1"># # look for scores</span>
        <span class="c1"># scores_folder = None</span>
        <span class="c1"># if &#39;scores&#39; in kwargs and kwargs[&#39;scores&#39;] in top_level_folders:</span>
        <span class="c1">#     scores_folder = kwargs[&#39;scores&#39;]</span>
        <span class="c1"># elif &#39;MS3&#39; in top_level_folders:</span>
        <span class="c1">#     scores_folder = &#39;MS3&#39;</span>
        <span class="c1"># elif &#39;scores&#39; in top_level_folders:</span>
        <span class="c1">#     scores_folder = &#39;scores&#39;</span>
        <span class="c1"># else:</span>
        <span class="c1">#     msg = f&quot;No scores folder found among {top_level_folders}.&quot;</span>
        <span class="c1">#     if &#39;scores&#39; not in kwargs:</span>
        <span class="c1">#         msg += &quot; If one of them has MuseScore files, indicate it by passing scores=&#39;scores_folder&#39;.&quot;</span>
        <span class="c1">#     self.logger.info(msg)</span>
        <span class="c1"># if scores_folder is not None:</span>
        <span class="c1">#     score_re = Score._make_extension_regex(convertible=convertible)</span>
        <span class="c1">#     scores_path = os.path.join(directory, scores_folder)</span>
        <span class="c1">#     score_paths = sorted(scan_directory(scores_path, file_re=score_re, recursive=recursive))</span>
        <span class="c1">#     score_ids = self.add_files(paths=score_paths, key=key)</span>
        <span class="c1">#     added_ids += score_ids</span>
        <span class="c1">#     score_fnames = self._get_unambiguous_fnames_from_ids(score_ids, key=key)</span>
        <span class="c1">#</span>
        <span class="c1">#     for fname, id in score_fnames.items():</span>
        <span class="c1">#         piece = self._get_piece(key, fname)</span>
        <span class="c1">#         piece.type2file_info[&#39;score&#39;] = self.id2file_info[id]</span>
        <span class="c1">#         self.id2piece_id[id] = (key, fname)</span>
        <span class="c1">#         # if fname in self.corpus2fname2score[key]:</span>
        <span class="c1">#         #     if self.corpus2fname2score[key][fname] == id:</span>
        <span class="c1">#         #         self.debug(f&quot;&#39;{fname} had already been matched to {id}.&quot;)</span>
        <span class="c1">#         #     else:</span>
        <span class="c1">#         #         self.warning(f&quot;&#39;{fname} had already been matched to {self.corpus2fname2score[key][fname]}&quot;)</span>
        <span class="c1">#     self.corpus2fname2score[key].update(score_fnames)</span>
        <span class="c1">#</span>
        <span class="c1"># # look for metadata</span>
        <span class="c1"># if &#39;metadata.tsv&#39; in top_level_files:</span>
        <span class="c1">#     default_metadata_path = os.path.join(directory, &#39;metadata.tsv&#39;)</span>
        <span class="c1">#     self.logger.debug(f&quot;&#39;metadata.tsv&#39; was detected and added.&quot;)</span>
        <span class="c1">#     added_ids += self.add_files(paths=default_metadata_path, key=key)</span>
        <span class="c1">#     metadata_id = added_ids[-1]</span>
        <span class="c1">#     self.parse_tsv(ids=[metadata_id])</span>
        <span class="c1">#     metadata_tsv = self._parsed_tsv[metadata_id]</span>
        <span class="c1">#     metadata_fnames = metadata_tsv.fnames</span>
        <span class="c1"># else:</span>
        <span class="c1">#     metadata_id = None</span>
        <span class="c1">#</span>
        <span class="c1">#</span>
        <span class="c1">#</span>
        <span class="c1"># return</span>
        <span class="c1"># paths = sorted(</span>
        <span class="c1">#     scan_directory(directory, file_re=file_re, folder_re=folder_re, exclude_re=exclude_re,</span>
        <span class="c1">#                    recursive=recursive, logger=self.logger))</span>
        <span class="c1"># if len(paths) == 0:</span>
        <span class="c1">#     self.logger.info(f&quot;No matching files found in {directory}.&quot;)</span>
        <span class="c1">#     return</span>
        <span class="c1"># added_ids = self.add_files(paths=paths, key=key)</span>
        <span class="c1"># if len(added_ids) == 0:</span>
        <span class="c1">#     self.logger.debug(f&quot;No files from {directory} have been added.&quot;)</span>
        <span class="c1">#     return</span>
        <span class="c1"># _, first_i = added_ids[0]</span>
        <span class="c1"># if &#39;metadata.tsv&#39; in self.files[key][first_i:]:</span>
        <span class="c1">#     self.logger.debug(f&quot;Found metadata.tsv for corpus &#39;{key}&#39;.&quot;)</span>
        <span class="c1"># elif &#39;metadata.tsv&#39; in self.files[key]:</span>
        <span class="c1">#     self.logger.debug(f&quot;Had already found metadata.tsv for corpus &#39;{key}&#39;.&quot;)</span>
        <span class="c1"># else:</span>
        <span class="c1">#     # if no metadata have been found (e.g. because excluded via file_re), add them if they&#39;re there</span>
        <span class="c1">#     default_metadata_path = os.path.join(directory, &#39;metadata.tsv&#39;)</span>
        <span class="c1">#     if os.path.isfile(default_metadata_path):</span>
        <span class="c1">#         self.logger.info(f&quot;&#39;metadata.tsv&#39; was detected and automatically added for corpus &#39;{key}&#39;.&quot;)</span>
        <span class="c1">#         metadata_id = self.add_files(paths=default_metadata_path, key=key)</span>
        <span class="c1">#         added_ids += metadata_id</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         self.logger.info(f&quot;No metadata found for corpus &#39;{key}&#39;.&quot;)</span>
        <span class="c1"># self.corpus_paths[key] = directory</span>
        <span class="c1"># self.look_for_ignored_warnings(directory, key)</span>


<div class="viewcode-block" id="Parse.add_dir"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.add_dir">[docs]</a>    <span class="k">def</span> <span class="nf">add_dir</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">directory</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                <span class="n">recursive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                <span class="o">**</span><span class="n">logger_cfg</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        This method decides if the directory ``directory`` contains several corpora or if it is a corpus</span>
<span class="sd">        itself, and calls :meth:`add_corpus` for each corpus.</span>

<span class="sd">        Args:</span>
<span class="sd">            directory: Directory to scan for corpora.</span>
<span class="sd">            recursive:</span>
<span class="sd">                By default, if any of the first-level subdirectories contains a &#39;metadata.tsv&#39; or is a git, all first-level</span>
<span class="sd">                subdirectories of ``directory`` are treated as corpora, i.e. one :class:`~.corpus.Corpus` object per folder is created.</span>
<span class="sd">                Pass False to prevent this, which is equivalent to calling :meth:`add_corpus(directory) &lt;add_corpus&gt;`</span>
<span class="sd">            **logger_cfg:</span>
<span class="sd">                Keyword arguments for configuring the logger of the new Corpus objects. E.g. ``level=&#39;d&#39;`` to see all debug messages.</span>
<span class="sd">                Note that the loggers are child loggers of this Parse object&#39;s logger and propagate, so it might filter debug messages.</span>
<span class="sd">                You can use _.change_logger_cfg(level=&#39;d&#39;) to change the level post hoc.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">directory</span> <span class="o">=</span> <span class="n">resolve_dir</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">isdir</span><span class="p">(</span><span class="n">directory</span><span class="p">):</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">warning</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">directory</span><span class="si">}</span><span class="s2"> is not an existing directory.&quot;</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="n">recursive</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_corpus</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="o">**</span><span class="n">logger_cfg</span><span class="p">)</span>
            <span class="k">return</span>

        <span class="c1"># new corpus/corpora to be added</span>
        <span class="n">subdir_corpora</span> <span class="o">=</span> <span class="nb">sorted</span><span class="p">(</span><span class="n">get_first_level_corpora</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">))</span>
        <span class="n">n_corpora</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">subdir_corpora</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">n_corpora</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Treating </span><span class="si">{</span><span class="n">directory</span><span class="si">}</span><span class="s2"> as corpus.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_corpus</span><span class="p">(</span><span class="n">directory</span><span class="p">,</span> <span class="o">**</span><span class="n">logger_cfg</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">debug</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;</span><span class="si">{</span><span class="n">n_corpora</span><span class="si">}</span><span class="s2"> individual corpora detected in </span><span class="si">{</span><span class="n">directory</span><span class="si">}</span><span class="s2">.&quot;</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">corpus_path</span> <span class="ow">in</span> <span class="n">subdir_corpora</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_corpus</span><span class="p">(</span><span class="n">corpus_path</span><span class="p">,</span> <span class="o">**</span><span class="n">logger_cfg</span><span class="p">)</span></div>


<div class="viewcode-block" id="Parse.add_files"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.add_files">[docs]</a>    <span class="k">def</span> <span class="nf">add_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">paths</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Collection</span><span class="p">[</span><span class="nb">str</span><span class="p">]],</span> <span class="n">corpus_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Deprecated: To deal with particular files only, use :meth:`add_corpus` passing the directory containing them and</span>
<span class="sd">        configure the :class`~.view.View` accordingly. This method here does it for you but easily leads to unexpected behaviour.</span>
<span class="sd">        It expects the file paths to point to files located in a shared corpus folder</span>
<span class="sd">        on some higher level or in folders for which :class:`~.corpus.Corpus` objects have already been created.</span>

<span class="sd">        Args:</span>
<span class="sd">            paths: Collection of file paths. Only existing files can be added.</span>
<span class="sd">            corpus_name:</span>

<span class="sd">                * By default, I will try to attribute the files to existing :class:`~.corpus.Corpus` objects based on their paths. This makes sense only when new files have</span>
<span class="sd">                  been created after the directories were scanned.</span>
<span class="sd">                * For paths that do no not contain an existing corpus_path, I will try to detect the parent directory that is a corpus (based on it being a git or containing a ``metadata.tsv``).</span>
<span class="sd">                  If this is without success for the first path, I will raise an error. Otherwise, all subsequent paths will be considered to be part of that same corpus (watch out</span>
<span class="sd">                  meaningless relative paths!).</span>
<span class="sd">                * You can pass a folder name contained in the first path to create a new corpus, assuming that all other paths are contained in it (watch out meaningless relative paths!).</span>
<span class="sd">                * Pass an existing corpus_name to add the files to a particular corpus. Note that all parseable files under the corpus_path are detected anyway, and if you add files</span>
<span class="sd">                  from other directories, it will lead to invalid relative paths that work only on your system. If you&#39;re adding files that have been created after the Corpus object</span>
<span class="sd">                  has, you can leave this parameter empty; paths will be attributed to the existing corpora automatically.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">resolved_paths</span> <span class="o">=</span> <span class="n">resolve_paths_argument</span><span class="p">(</span><span class="n">paths</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">resolved_paths</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="k">if</span> <span class="n">corpus_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">add_to_existing</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
            <span class="n">no_parent</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">path</span> <span class="ow">in</span> <span class="n">resolved_paths</span><span class="p">:</span>
                <span class="n">part_of</span> <span class="o">=</span> <span class="kc">None</span>
                <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus_path</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus_paths</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">if</span> <span class="n">corpus_path</span> <span class="ow">in</span> <span class="n">path</span><span class="p">:</span>
                        <span class="n">part_of</span> <span class="o">=</span> <span class="n">corpus_name</span>
                        <span class="n">add_to_existing</span><span class="p">[</span><span class="n">part_of</span><span class="p">]</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
                        <span class="k">break</span>
                <span class="k">if</span> <span class="n">part_of</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">no_parent</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">path</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">paths</span> <span class="ow">in</span> <span class="n">add_to_existing</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">get_corpus</span><span class="p">(</span><span class="n">corpus_name</span><span class="p">)</span><span class="o">.</span><span class="n">add_file_paths</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">no_parent</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="c1"># paths are expected to be contained in one and the same corpus directory</span>
                <span class="n">first_path</span> <span class="o">=</span> <span class="n">no_parent</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                <span class="n">directory</span> <span class="o">=</span> <span class="n">path2parent_corpus</span><span class="p">(</span><span class="n">first_path</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">directory</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;No parent of </span><span class="si">{</span><span class="n">first_path</span><span class="si">}</span><span class="s2"> has been recognized as a corpus by being a git or containing a &#39;metadata.tsv&#39;. Use _.add_corpus()&quot;</span><span class="p">)</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">add_corpus</span><span class="p">(</span><span class="n">directory</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">corpus_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus_paths</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">get_corpus</span><span class="p">(</span><span class="n">corpus_name</span><span class="p">)</span><span class="o">.</span><span class="n">add_file_paths</span><span class="p">(</span><span class="n">paths</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="c1"># find the path according to the corpus_name</span>
            <span class="n">first_path</span> <span class="o">=</span> <span class="n">resolved_paths</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">corpus_name</span> <span class="ow">in</span> <span class="n">first_path</span><span class="p">:</span>
                <span class="k">while</span> <span class="kc">True</span><span class="p">:</span>
                    <span class="n">tmp_path</span><span class="p">,</span> <span class="n">last_component</span> <span class="o">=</span> <span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">split</span><span class="p">(</span><span class="n">first_path</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">tmp_path</span> <span class="o">==</span> <span class="n">first_path</span><span class="p">:</span>
                        <span class="c1"># reached the root</span>
                        <span class="n">first_path</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span>
                        <span class="k">break</span>
                    <span class="k">if</span> <span class="n">last_component</span> <span class="o">==</span> <span class="n">corpus_name</span><span class="p">:</span>
                        <span class="c1"># first_path is the corpus first_path</span>
                        <span class="k">break</span>
                    <span class="n">first_path</span> <span class="o">=</span> <span class="n">tmp_path</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">first_path</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span>
            <span class="k">if</span> <span class="n">first_path</span> <span class="o">==</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;corpus_name needs to be a folder contained in the first path, but &#39;</span><span class="si">{</span><span class="n">corpus_name</span><span class="si">}</span><span class="s2">&#39; isn&#39;t.&quot;</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">add_corpus</span><span class="p">(</span><span class="n">first_path</span><span class="p">)</span></div>
            <span class="c1"># corpus = self.get_corpus(corpus_name)</span>
            <span class="c1"># new_view = create_view_from_parameters(only_metadata_fnames=False, exclude_review=False, paths=paths)</span>
            <span class="c1"># corpus.set_view(new_view)</span>

    <span class="k">def</span> <span class="nf">color_non_chord_tones</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                              <span class="n">color_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;red&#39;</span><span class="p">,</span>
                              <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                              <span class="n">force</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                              <span class="n">choose</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;ask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">CorpusFnameTuple</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="n">FileDataframeTuple</span><span class="p">]]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">(</span><span class="n">view_name</span><span class="p">):</span>
            <span class="n">fname2reports</span> <span class="o">=</span> <span class="n">corpus</span><span class="o">.</span><span class="n">color_non_chord_tones</span><span class="p">(</span><span class="n">color_name</span><span class="p">,</span>
                                                    <span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">,</span>
                                                    <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">,</span>
                                                    <span class="n">choose</span><span class="o">=</span><span class="n">choose</span><span class="p">)</span>
            <span class="n">result</span><span class="o">.</span><span class="n">update</span><span class="p">({(</span><span class="n">corpus_name</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span> <span class="n">report</span> <span class="k">for</span> <span class="n">fname</span><span class="p">,</span> <span class="n">report</span> <span class="ow">in</span> <span class="n">fname2reports</span><span class="o">.</span><span class="n">items</span><span class="p">()})</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Parse.change_labels_cfg"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.change_labels_cfg">[docs]</a>    <span class="k">def</span> <span class="nf">change_labels_cfg</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">labels_cfg</span><span class="o">=</span><span class="p">{},</span> <span class="n">staff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">voice</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">harmony_layer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">positioning</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">decode</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">column_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">color_format</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Update :obj:`Parse.labels_cfg` and retrieve new &#39;labels&#39; tables accordingly.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        labels_cfg : :obj:`dict`</span>
<span class="sd">            Using an entire dictionary or, to change only particular options, choose from:</span>
<span class="sd">        staff, voice, harmony_layer, positioning, decode, column_name</span>
<span class="sd">            Arguments as they will be passed to :py:meth:`~ms3.annotations.Annotations.get_labels`</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">keys</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;staff&#39;</span><span class="p">,</span> <span class="s1">&#39;voice&#39;</span><span class="p">,</span> <span class="s1">&#39;harmony_layer&#39;</span><span class="p">,</span> <span class="s1">&#39;positioning&#39;</span><span class="p">,</span> <span class="s1">&#39;decode&#39;</span><span class="p">,</span> <span class="s1">&#39;column_name&#39;</span><span class="p">,</span> <span class="s1">&#39;color_format&#39;</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">keys</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()[</span><span class="n">k</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">val</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">labels_cfg</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">val</span>
        <span class="n">updated</span> <span class="o">=</span> <span class="n">update_labels_cfg</span><span class="p">(</span><span class="n">labels_cfg</span><span class="p">,</span> <span class="n">logger</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">labels_cfg</span><span class="o">.</span><span class="n">update</span><span class="p">(</span><span class="n">updated</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">score</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parsed_mscx</span><span class="o">.</span><span class="n">values</span><span class="p">():</span>
            <span class="n">score</span><span class="o">.</span><span class="n">change_labels_cfg</span><span class="p">(</span><span class="n">labels_cfg</span><span class="o">=</span><span class="n">updated</span><span class="p">)</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_labellists</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_extract_and_cache_dataframes</span><span class="p">(</span><span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">,</span> <span class="n">labels</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div>

<div class="viewcode-block" id="Parse.compare_labels"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.compare_labels">[docs]</a>    <span class="k">def</span> <span class="nf">compare_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="n">key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;detached&#39;</span><span class="p">,</span>
                       <span class="n">new_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;ms3_darkgreen&#39;</span><span class="p">,</span>
                       <span class="n">old_color</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;ms3_darkred&#39;</span><span class="p">,</span>
                       <span class="n">detached_is_newer</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">add_to_rna</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                       <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">int</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot; Compare detached labels ``key`` to the ones attached to the Score to create a diff.</span>
<span class="sd">        By default, the attached labels are considered as the reviewed version and labels that have changed or been added</span>
<span class="sd">        in comparison to the detached labels are colored in green; whereas the previous versions of changed labels are</span>
<span class="sd">        attached to the Score in red, just like any deleted label.</span>

<span class="sd">        Args:</span>
<span class="sd">            key: Key of the detached labels you want to compare to the ones in the score.</span>
<span class="sd">            new_color, old_color:</span>
<span class="sd">                The colors by which new and old labels are differentiated. Identical labels remain unchanged. Colors can be</span>
<span class="sd">                CSS colors or MuseScore colors (see :py:attr:`utils.MS3_COLORS`).</span>
<span class="sd">            detached_is_newer:</span>
<span class="sd">                Pass True if the detached labels are to be added with ``new_color`` whereas the attached changed labels</span>
<span class="sd">                will turn ``old_color``, as opposed to the default.</span>
<span class="sd">            add_to_rna:</span>
<span class="sd">                By default, new labels are attached to the Roman Numeral layer.</span>
<span class="sd">                Pass False to attach them to the chord layer instead.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Number of scores in which labels have changed.</span>
<span class="sd">            Number of scores in which no label has chnged.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">changed</span><span class="p">,</span> <span class="n">unchanged</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">):</span>
            <span class="n">c</span><span class="p">,</span> <span class="n">u</span> <span class="o">=</span> <span class="n">corpus</span><span class="o">.</span><span class="n">compare_labels</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
                                        <span class="n">new_color</span><span class="o">=</span><span class="n">new_color</span><span class="p">,</span>
                                        <span class="n">old_color</span><span class="o">=</span><span class="n">old_color</span><span class="p">,</span>
                                        <span class="n">detached_is_newer</span><span class="o">=</span><span class="n">detached_is_newer</span><span class="p">,</span>
                                        <span class="n">add_to_rna</span><span class="o">=</span><span class="n">add_to_rna</span><span class="p">,</span>
                                        <span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">)</span>
            <span class="n">changed</span> <span class="o">+=</span> <span class="n">c</span>
            <span class="n">unchanged</span> <span class="o">+=</span> <span class="n">u</span>
        <span class="k">return</span> <span class="n">changed</span><span class="p">,</span> <span class="n">unchanged</span></div>


    <span class="k">def</span> <span class="nf">count_changed_scores</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">):</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="n">corpus</span><span class="o">.</span><span class="n">count_changed_scores</span><span class="p">()</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">(</span><span class="n">view_name</span><span class="p">))</span>

<div class="viewcode-block" id="Parse.count_extensions"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.count_extensions">[docs]</a>    <span class="k">def</span> <span class="nf">count_extensions</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                         <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                         <span class="n">per_piece</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="n">include_metadata</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                         <span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Count file extensions.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keys : :obj:`str` or :obj:`~collections.abc.Collection`, optional</span>
<span class="sd">            Key(s) for which to count file extensions.  By default, all keys are selected.</span>
<span class="sd">        ids : :obj:`~collections.abc.Collection`</span>
<span class="sd">            If you pass a collection of IDs, ``keys`` is ignored and only the selected extensions are counted.</span>
<span class="sd">        per_key : :obj:`bool`, optional</span>
<span class="sd">            If set to True, the results are returned as a dict {key: Counter},</span>
<span class="sd">            otherwise the counts are summed up in one Counter.</span>
<span class="sd">        per_subdir : :obj:`bool`, optional</span>
<span class="sd">            If set to True, the results are returned as {key: {subdir: Counter} }. ``per_key=True`` is therefore implied.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :obj:`dict`</span>
<span class="sd">            By default, the function returns a Counter of file extensions (Counters are converted to dicts).</span>
<span class="sd">            If ``per_key`` is set to True, a dictionary {key: Counter} is returned, separating the counts.</span>
<span class="sd">            If ``per_subdir`` is set to True, a dictionary {key: {subdir: Counter} } is returned.</span>

<span class="sd">        Args:</span>
<span class="sd">            view_name:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">extension_counters</span> <span class="o">=</span> <span class="p">{</span><span class="n">corpus_name</span><span class="p">:</span> <span class="n">corpus</span><span class="o">.</span><span class="n">count_extensions</span><span class="p">(</span><span class="n">view_name</span><span class="p">,</span> <span class="n">include_metadata</span><span class="o">=</span><span class="n">include_metadata</span><span class="p">)</span> <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">(</span><span class="n">view_name</span><span class="p">)}</span>
        <span class="k">if</span> <span class="n">per_piece</span><span class="p">:</span>
            <span class="k">return</span> <span class="p">{(</span><span class="n">corpus_name</span><span class="p">,</span> <span class="n">fname</span><span class="p">):</span> <span class="nb">dict</span><span class="p">(</span><span class="n">cnt</span><span class="p">)</span> <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">fname2cnt</span> <span class="ow">in</span> <span class="n">extension_counters</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">for</span> <span class="n">fname</span><span class="p">,</span> <span class="n">cnt</span> <span class="ow">in</span> <span class="n">fname2cnt</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>
        <span class="k">return</span> <span class="p">{</span><span class="n">corpus_name</span><span class="p">:</span> <span class="nb">dict</span><span class="p">(</span><span class="nb">sum</span><span class="p">(</span><span class="n">fname2cnt</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">Counter</span><span class="p">()))</span> <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">fname2cnt</span> <span class="ow">in</span> <span class="n">extension_counters</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span></div>


    <span class="k">def</span> <span class="nf">count_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                    <span class="n">detected</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">parsed</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                    <span class="n">as_dict</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                    <span class="n">drop_zero</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="nb">dict</span><span class="p">]:</span>
        <span class="n">all_counts</span> <span class="o">=</span> <span class="p">{</span><span class="n">corpus_name</span><span class="p">:</span> <span class="n">corpus</span><span class="o">.</span><span class="n">_summed_file_count</span><span class="p">(</span><span class="n">types</span><span class="o">=</span><span class="n">detected</span><span class="p">,</span> <span class="n">parsed</span><span class="o">=</span><span class="n">parsed</span><span class="p">,</span> <span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">)}</span>
        <span class="n">counts_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="o">.</span><span class="n">from_dict</span><span class="p">(</span><span class="n">all_counts</span><span class="p">,</span> <span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">,</span> <span class="n">dtype</span><span class="o">=</span><span class="s1">&#39;Int64&#39;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">drop_zero</span><span class="p">:</span>
            <span class="n">empty_cols</span> <span class="o">=</span> <span class="n">counts_df</span><span class="o">.</span><span class="n">columns</span><span class="p">[</span><span class="n">counts_df</span><span class="o">.</span><span class="n">sum</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">]</span>
            <span class="n">counts_df</span> <span class="o">=</span> <span class="n">counts_df</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">columns</span><span class="o">=</span><span class="n">empty_cols</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">as_dict</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">counts_df</span><span class="o">.</span><span class="n">to_dict</span><span class="p">(</span><span class="n">orient</span><span class="o">=</span><span class="s1">&#39;index&#39;</span><span class="p">)</span>
        <span class="n">counts_df</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="s1">&#39;corpus&#39;</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">counts_df</span>

    <span class="k">def</span> <span class="nf">count_parsed_scores</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_parsed_score_files</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">count_parsed_tsvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_parsed_tsv_files</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">count_unparsed_scores</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_parsed_score_files</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">count_unparsed_tsvs</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">int</span><span class="p">:</span>
        <span class="k">return</span> <span class="nb">sum</span><span class="p">(</span><span class="nb">map</span><span class="p">(</span><span class="nb">len</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_parsed_tsv_files</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">)</span><span class="o">.</span><span class="n">values</span><span class="p">()))</span>

    <span class="k">def</span> <span class="nf">create_missing_metadata_tsv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                                    <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">corpus</span><span class="o">.</span><span class="n">metadata_tsv</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">path</span> <span class="o">=</span> <span class="n">corpus</span><span class="o">.</span><span class="n">create_metadata_tsv</span><span class="p">()</span>


    <span class="k">def</span> <span class="nf">extract_facets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="n">facets</span><span class="p">:</span> <span class="n">ScoreFacets</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">force</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">choose</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;ask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span>
                       <span class="n">unfold</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">interval_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">flat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">concatenate</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="n">CorpusFnameTuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span>  <span class="n">List</span><span class="p">[</span><span class="n">FileDataframeTuple</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">FileDataframeTuple</span><span class="p">]]]]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_corpus_data</span><span class="p">(</span><span class="s1">&#39;extract_facets&#39;</span><span class="p">,</span>
                                           <span class="n">facets</span><span class="o">=</span><span class="n">facets</span><span class="p">,</span>
                                           <span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">,</span>
                                           <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">,</span>
                                           <span class="n">choose</span><span class="o">=</span><span class="n">choose</span><span class="p">,</span>
                                           <span class="n">unfold</span><span class="o">=</span><span class="n">unfold</span><span class="p">,</span>
                                           <span class="n">interval_index</span><span class="o">=</span><span class="n">interval_index</span><span class="p">,</span>
                                           <span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">,</span>
                                           <span class="n">concatenate</span><span class="o">=</span><span class="n">concatenate</span><span class="p">,</span>
                                           <span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_all_parsed</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">facets</span><span class="p">:</span> <span class="n">FacetArguments</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">force</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">choose</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;ask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span>
                       <span class="n">flat</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">include_empty</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">concatenate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="n">CorpusFnameTuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">FileParsedTuple</span><span class="p">],</span> <span class="n">List</span><span class="p">[</span><span class="n">FileParsedTuple</span><span class="p">]]]]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_corpus_data</span><span class="p">(</span><span class="s1">&#39;get_all_parsed&#39;</span><span class="p">,</span>
                                           <span class="n">facets</span><span class="o">=</span><span class="n">facets</span><span class="p">,</span>
                                           <span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">,</span>
                                           <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">,</span>
                                           <span class="n">choose</span><span class="o">=</span><span class="n">choose</span><span class="p">,</span>
                                           <span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">,</span>
                                           <span class="n">include_empty</span><span class="o">=</span><span class="n">include_empty</span><span class="p">,</span>
                                           <span class="n">concatenate</span><span class="o">=</span><span class="n">concatenate</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_corpus</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Corpus</span><span class="p">:</span>
        <span class="k">assert</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus_objects</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;Don&#39;t have a corpus called &#39;</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">&#39;, only </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus_objects</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus_objects</span><span class="p">[</span><span class="n">name</span><span class="p">]</span>


<div class="viewcode-block" id="Parse.get_dataframes"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.get_dataframes">[docs]</a>    <span class="k">def</span> <span class="nf">get_dataframes</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="n">notes</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">rests</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">notes_and_rests</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">measures</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">events</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">chords</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">expanded</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">form_labels</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">cadences</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">force</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">choose</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;ask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span>
                       <span class="n">unfold</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">interval_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">flat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                       <span class="n">include_empty</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                      <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="n">CorpusFnameTuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span>  <span class="n">List</span><span class="p">[</span><span class="n">FileDataframeTuple</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">FileDataframeTuple</span><span class="p">]]]]:</span>
        <span class="sd">&quot;&quot;&quot;Renamed to :meth:`get_facets`.&quot;&quot;&quot;</span>
        <span class="n">l</span> <span class="o">=</span> <span class="nb">locals</span><span class="p">()</span>
        <span class="n">facets</span> <span class="o">=</span> <span class="p">[</span><span class="n">facet</span> <span class="k">for</span> <span class="n">facet</span> <span class="ow">in</span> <span class="n">ScoreFacet</span><span class="o">.</span><span class="n">__args__</span> <span class="k">if</span> <span class="n">l</span><span class="p">[</span><span class="n">facet</span><span class="p">]]</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_facets</span><span class="p">(</span><span class="n">facets</span><span class="o">=</span><span class="n">facets</span><span class="p">,</span>
                               <span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">,</span>
                               <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">,</span>
                               <span class="n">choose</span><span class="o">=</span><span class="n">choose</span><span class="p">,</span>
                               <span class="n">unfold</span><span class="o">=</span><span class="n">unfold</span><span class="p">,</span>
                               <span class="n">interval_index</span><span class="o">=</span><span class="n">interval_index</span><span class="p">,</span>
                               <span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">,</span>
                               <span class="n">include_empty</span><span class="o">=</span><span class="n">include_empty</span><span class="p">)</span></div>


    <span class="k">def</span> <span class="nf">get_facets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                   <span class="n">facets</span><span class="p">:</span> <span class="n">ScoreFacets</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                   <span class="n">force</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                   <span class="n">choose</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;ask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span>
                   <span class="n">unfold</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                   <span class="n">interval_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                   <span class="n">flat</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">include_empty</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                   <span class="n">concatenate</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                   <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Union</span><span class="p">[</span><span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">,</span> <span class="n">Dict</span><span class="p">[</span><span class="n">CorpusFnameTuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span>  <span class="n">List</span><span class="p">[</span><span class="n">FileDataframeTuple</span><span class="p">]],</span> <span class="n">List</span><span class="p">[</span><span class="n">FileDataframeTuple</span><span class="p">]]]]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_corpus_data</span><span class="p">(</span><span class="s1">&#39;get_facets&#39;</span><span class="p">,</span>
                                           <span class="n">facets</span><span class="o">=</span><span class="n">facets</span><span class="p">,</span>
                                           <span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">,</span>
                                           <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">,</span>
                                           <span class="n">choose</span><span class="o">=</span><span class="n">choose</span><span class="p">,</span>
                                           <span class="n">unfold</span><span class="o">=</span><span class="n">unfold</span><span class="p">,</span>
                                           <span class="n">interval_index</span><span class="o">=</span><span class="n">interval_index</span><span class="p">,</span>
                                           <span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">,</span>
                                           <span class="n">include_empty</span><span class="o">=</span><span class="n">include_empty</span><span class="p">,</span>
                                           <span class="n">concatenate</span><span class="o">=</span><span class="n">concatenate</span><span class="p">,</span>
                                           <span class="p">)</span>

    <span class="k">def</span> <span class="nf">get_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">facets</span><span class="p">:</span> <span class="n">FacetArguments</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                  <span class="n">parsed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                  <span class="n">unparsed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                  <span class="n">choose</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;ask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span>
                  <span class="n">flat</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                  <span class="n">include_empty</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                  <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">CorpusFnameTuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">FileDict</span><span class="p">,</span> <span class="n">FileList</span><span class="p">]]:</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_aggregate_corpus_data</span><span class="p">(</span><span class="s1">&#39;get_files&#39;</span><span class="p">,</span>
                                           <span class="n">facets</span><span class="o">=</span><span class="n">facets</span><span class="p">,</span>
                                           <span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">,</span>
                                           <span class="n">parsed</span><span class="o">=</span><span class="n">parsed</span><span class="p">,</span>
                                           <span class="n">unparsed</span><span class="o">=</span><span class="n">unparsed</span><span class="p">,</span>
                                           <span class="n">choose</span><span class="o">=</span><span class="n">choose</span><span class="p">,</span>
                                           <span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">,</span>
                                           <span class="n">include_empty</span><span class="o">=</span><span class="n">include_empty</span>
                                           <span class="p">)</span>


<div class="viewcode-block" id="Parse.get_piece"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.get_piece">[docs]</a>    <span class="k">def</span> <span class="nf">get_piece</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">corpus_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span> <span class="n">fname</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Piece</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Returns an existing Piece object.&quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">corpus_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus_objects</span><span class="p">,</span> <span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">corpus_name</span><span class="si">}</span><span class="s2">&#39; is not an existing corpus. Choose from </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">corpus_objects</span><span class="o">.</span><span class="n">keys</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus_objects</span><span class="p">[</span><span class="n">corpus_name</span><span class="p">]</span><span class="o">.</span><span class="n">get_piece</span><span class="p">(</span><span class="n">fname</span><span class="p">)</span></div>

<div class="viewcode-block" id="Parse.get_view"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.get_view">[docs]</a>    <span class="k">def</span> <span class="nf">get_view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="o">**</span><span class="n">config</span>
                 <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">View</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Retrieve an existing or create a new View object, potentially while updating the config.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">view_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="p">:</span>
            <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="p">[</span><span class="n">view_name</span><span class="p">]</span>
        <span class="k">elif</span> <span class="n">view_name</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span><span class="o">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">view_name</span><span class="p">:</span>
            <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_view</span><span class="p">()</span><span class="o">.</span><span class="n">copy</span><span class="p">(</span><span class="n">new_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">)</span>
            <span class="n">old_name</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">name</span>
            <span class="n">view</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">view_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="p">[</span><span class="n">view_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;New view &#39;</span><span class="si">{</span><span class="n">view_name</span><span class="si">}</span><span class="s2">&#39; created as a copy of &#39;</span><span class="si">{</span><span class="n">old_name</span><span class="si">}</span><span class="s2">&#39;.&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">config</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">view</span><span class="o">.</span><span class="n">update_config</span><span class="p">(</span><span class="o">**</span><span class="n">config</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">view</span></div>


    <span class="k">def</span> <span class="nf">info</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">return_str</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span> <span class="n">show_discarded</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;&quot;&quot;&quot;</span>
        <span class="n">header</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;All corpora&quot;</span>
        <span class="n">header</span> <span class="o">+=</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span> <span class="o">+</span> <span class="s2">&quot;-&quot;</span> <span class="o">*</span> <span class="nb">len</span><span class="p">(</span><span class="n">header</span><span class="p">)</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n</span><span class="s2">&quot;</span>

        <span class="c1"># start info message with the names of the available views, the header, and info on the active view.</span>
        <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="n">view_name</span><span class="p">)</span>
        <span class="n">view</span><span class="o">.</span><span class="n">reset_filtering_data</span><span class="p">()</span>
        <span class="n">msg</span> <span class="o">=</span> <span class="n">available_views2str</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="p">,</span> <span class="n">view_name</span><span class="p">)</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="n">header</span>
        <span class="n">view_info</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;View: </span><span class="si">{</span><span class="n">view</span><span class="si">}</span><span class="s2">&quot;</span>
        <span class="k">if</span> <span class="n">view_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">corpus_views</span> <span class="o">=</span> <span class="p">[</span><span class="n">corpus</span><span class="o">.</span><span class="n">get_view</span><span class="p">()</span><span class="o">.</span><span class="n">name</span> <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">)]</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">corpus_views</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                <span class="n">view_info</span> <span class="o">=</span> <span class="sa">f</span><span class="s2">&quot;This is a mixed view. Call _.info(view_name) to see a homogeneous one.&quot;</span>
        <span class="n">msg</span> <span class="o">+=</span> <span class="n">view_info</span> <span class="o">+</span> <span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">&quot;</span>

        <span class="c1"># Show info on all pieces and files included in the active view</span>
        <span class="n">counts_df</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_files</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">)</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">counts_df</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_detected</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;No files detected. Use _.add_corpus().&#39;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;No files selected under the current view. You could use _.all to see everything.&#39;</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">counts_df</span><span class="o">.</span><span class="n">isna</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">()</span><span class="o">.</span><span class="n">any</span><span class="p">():</span>
                <span class="n">counts_df</span> <span class="o">=</span> <span class="n">counts_df</span><span class="o">.</span><span class="n">fillna</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">astype</span><span class="p">(</span><span class="s1">&#39;int&#39;</span><span class="p">)</span>
            <span class="n">additional_columns</span> <span class="o">=</span> <span class="p">[]</span>
            <span class="k">for</span> <span class="n">corpus_name</span> <span class="ow">in</span> <span class="n">counts_df</span><span class="o">.</span><span class="n">index</span><span class="p">:</span>
                <span class="n">corpus</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_corpus</span><span class="p">(</span><span class="n">corpus_name</span><span class="p">)</span>
                <span class="n">has_metadata</span> <span class="o">=</span> <span class="s1">&#39;no&#39;</span> <span class="k">if</span> <span class="n">corpus</span><span class="o">.</span><span class="n">metadata_tsv</span> <span class="ow">is</span> <span class="kc">None</span> <span class="k">else</span> <span class="s1">&#39;yes&#39;</span>
                <span class="n">corpus_view</span> <span class="o">=</span> <span class="n">corpus</span><span class="o">.</span><span class="n">get_view</span><span class="p">()</span><span class="o">.</span><span class="n">name</span>
                <span class="n">additional_columns</span><span class="o">.</span><span class="n">append</span><span class="p">([</span><span class="n">has_metadata</span><span class="p">,</span> <span class="n">corpus_view</span><span class="p">])</span>
            <span class="n">additional_columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">(</span><span class="n">additional_columns</span><span class="p">,</span> <span class="n">columns</span><span class="o">=</span><span class="p">[(</span><span class="s1">&#39;has&#39;</span><span class="p">,</span> <span class="s1">&#39;metadata&#39;</span><span class="p">),</span> <span class="p">(</span><span class="s1">&#39;active&#39;</span><span class="p">,</span> <span class="s1">&#39;view&#39;</span><span class="p">)],</span> <span class="n">index</span><span class="o">=</span><span class="n">counts_df</span><span class="o">.</span><span class="n">index</span><span class="p">)</span>
            <span class="n">info_df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">additional_columns</span><span class="p">,</span> <span class="n">counts_df</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
            <span class="n">info_df</span><span class="o">.</span><span class="n">columns</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">MultiIndex</span><span class="o">.</span><span class="n">from_tuples</span><span class="p">(</span><span class="n">info_df</span><span class="o">.</span><span class="n">columns</span><span class="p">)</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="n">info_df</span><span class="o">.</span><span class="n">to_string</span><span class="p">()</span>
            <span class="n">n_changed_scores</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">count_changed_scores</span><span class="p">(</span><span class="n">view_name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">n_changed_scores</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="si">{</span><span class="n">n_changed_scores</span><span class="si">}</span><span class="s2"> scores have changed since parsing.&quot;</span>
            <span class="n">filtering_report</span> <span class="o">=</span> <span class="n">view</span><span class="o">.</span><span class="n">filtering_report</span><span class="p">(</span><span class="n">show_discarded</span><span class="o">=</span><span class="n">show_discarded</span><span class="p">,</span> <span class="n">return_str</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">filtering_report</span> <span class="o">!=</span> <span class="s1">&#39;&#39;</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;</span><span class="se">\n\n</span><span class="s1">&#39;</span> <span class="o">+</span> <span class="n">filtering_report</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">n_orphans</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
            <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\n</span><span class="s2">There are </span><span class="si">{</span><span class="bp">self</span><span class="o">.</span><span class="n">n_orphans</span><span class="si">}</span><span class="s2"> orphans that could not be attributed to any of the respective corpus&#39;s fnames&quot;</span>
            <span class="k">if</span> <span class="n">show_discarded</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s1">&#39;:&#39;</span>
                <span class="k">for</span> <span class="n">name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                    <span class="k">if</span> <span class="n">corpus</span><span class="o">.</span><span class="n">n_orphans</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="n">msg</span> <span class="o">+=</span> <span class="sa">f</span><span class="s2">&quot;</span><span class="se">\n\t</span><span class="si">{</span><span class="n">name</span><span class="si">}</span><span class="s2">: </span><span class="si">{</span><span class="nb">list</span><span class="p">(</span><span class="n">corpus</span><span class="o">.</span><span class="n">ix2orphan_file</span><span class="o">.</span><span class="n">values</span><span class="p">())</span><span class="si">}</span><span class="s2">&quot;</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">msg</span> <span class="o">+=</span> <span class="s2">&quot;.&quot;</span>
        <span class="k">if</span> <span class="n">return_str</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">msg</span>
        <span class="nb">print</span><span class="p">(</span><span class="n">msg</span><span class="p">)</span>
        <span class="c1"># ids = list(self._iterids(keys))</span>
        <span class="c1"># info = f&quot;{len(ids)} files.\n&quot;</span>
        <span class="c1"># if subdirs:</span>
        <span class="c1">#     exts = self.count_extensions(keys, per_subdir=True)</span>
        <span class="c1">#     for key, subdir_exts in exts.items():</span>
        <span class="c1">#         info += key + &#39;\n&#39;</span>
        <span class="c1">#         for line in pretty_dict(subdir_exts).split(&#39;\n&#39;):</span>
        <span class="c1">#             info += &#39;    &#39; + line + &#39;\n&#39;</span>
        <span class="c1"># else:</span>
        <span class="c1">#     exts = self.count_extensions(keys, per_key=True)</span>
        <span class="c1">#     info += pretty_dict(exts, heading=&#39;EXTENSIONS&#39;)</span>
        <span class="c1"># parsed_mscx_ids = [id for id in ids if id in self._parsed_mscx]</span>
        <span class="c1"># parsed_mscx = len(parsed_mscx_ids)</span>
        <span class="c1"># ext_counts = self.count_extensions(keys, per_key=False)</span>
        <span class="c1"># others = len(self._score_ids(opposite=True))</span>
        <span class="c1"># mscx = len(self._score_ids())</span>
        <span class="c1"># by_conversion = len(self._score_ids(native=False))</span>
        <span class="c1"># if parsed_mscx &gt; 0:</span>
        <span class="c1">#</span>
        <span class="c1">#     if parsed_mscx == mscx:</span>
        <span class="c1">#         info += f&quot;\n\nAll {mscx} MSCX files have been parsed.&quot;</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         info += f&quot;\n\n{parsed_mscx}/{mscx} MSCX files have been parsed.&quot;</span>
        <span class="c1">#     annotated = sum(True for id in parsed_mscx_ids if id in self._annotations)</span>
        <span class="c1">#     if annotated == mscx:</span>
        <span class="c1">#         info += f&quot;\n\nThey all have annotations attached.&quot;</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         info += f&quot;\n\n{annotated} of them have annotations attached.&quot;</span>
        <span class="c1">#     if annotated &gt; 0:</span>
        <span class="c1">#         layers = self.count_annotation_layers(keys, which=&#39;attached&#39;, per_key=True)</span>
        <span class="c1">#         info += f&quot;\n{pretty_dict(layers, heading=&#39;ANNOTATION LAYERS&#39;)}&quot;</span>
        <span class="c1">#</span>
        <span class="c1">#     detached = sum(True for id in parsed_mscx_ids if self._parsed_mscx[id].has_detached_annotations)</span>
        <span class="c1">#     if detached &gt; 0:</span>
        <span class="c1">#         info += f&quot;\n\n{detached} of them have detached annotations:&quot;</span>
        <span class="c1">#         layers = self.count_annotation_layers(keys, which=&#39;detached&#39;, per_key=True)</span>
        <span class="c1">#         try:</span>
        <span class="c1">#             info += f&quot;\n{pretty_dict(layers, heading=&#39;ANNOTATION LAYERS&#39;)}&quot;</span>
        <span class="c1">#         except:</span>
        <span class="c1">#             print(layers)</span>
        <span class="c1">#             raise</span>
        <span class="c1"># elif &#39;.mscx&#39; in ext_counts:</span>
        <span class="c1">#     if mscx &gt; 0:</span>
        <span class="c1">#         info += f&quot;\n\nNone of the {mscx} score files have been parsed.&quot;</span>
        <span class="c1">#         if by_conversion &gt; 0 and self.ms is None:</span>
        <span class="c1">#             info += f&quot;\n{by_conversion} files would need to be converted, for which you need to set the &#39;ms&#39; property to your MuseScore 3 executable.&quot;</span>
        <span class="c1"># if self.ms is not None:</span>
        <span class="c1">#     info += &quot;\n\nMuseScore 3 executable has been found.&quot;</span>
        <span class="c1">#</span>
        <span class="c1">#</span>
        <span class="c1"># parsed_tsv_ids = [id for id in ids if id in self._parsed_tsv]</span>
        <span class="c1"># parsed_tsv = len(parsed_tsv_ids)</span>
        <span class="c1"># if parsed_tsv &gt; 0:</span>
        <span class="c1">#     annotations = sum(True for id in parsed_tsv_ids if id in self._annotations)</span>
        <span class="c1">#     if parsed_tsv == others:</span>
        <span class="c1">#         info += f&quot;\n\nAll {others} tabular files have been parsed, {annotations} of them as Annotations object(s).&quot;</span>
        <span class="c1">#     else:</span>
        <span class="c1">#         info += f&quot;\n\n{parsed_tsv}/{others} tabular files have been parsed, {annotations} of them as Annotations object(s).&quot;</span>
        <span class="c1">#     if annotations &gt; 0:</span>
        <span class="c1">#         layers = self.count_annotation_layers(keys, which=&#39;tsv&#39;, per_key=True)</span>
        <span class="c1">#         info += f&quot;\n{pretty_dict(layers, heading=&#39;ANNOTATION LAYERS&#39;)}&quot;</span>
        <span class="c1">#</span>
        <span class="c1"># if return_str:</span>
        <span class="c1">#     return info</span>
        <span class="c1"># print(info)</span>

<div class="viewcode-block" id="Parse.iter_corpora"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.iter_corpora">[docs]</a>    <span class="k">def</span> <span class="nf">iter_corpora</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Generator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Corpus</span><span class="p">],</span> <span class="kc">None</span><span class="p">,</span> <span class="kc">None</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Iterate through corpora under the current or specified view.&quot;&quot;&quot;</span>
        <span class="n">view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="n">view_name</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="n">view</span><span class="o">.</span><span class="n">filter_by_token</span><span class="p">(</span><span class="s1">&#39;corpora&#39;</span><span class="p">,</span> <span class="bp">self</span><span class="p">):</span>
            <span class="k">if</span> <span class="n">view_name</span> <span class="ow">not</span> <span class="ow">in</span> <span class="n">corpus</span><span class="o">.</span><span class="n">_views</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">view_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                    <span class="n">corpus</span><span class="o">.</span><span class="n">set_view</span><span class="p">(</span><span class="n">view</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="n">corpus</span><span class="o">.</span><span class="n">set_view</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">view_name</span><span class="p">:</span> <span class="n">view</span><span class="p">})</span>
            <span class="k">yield</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span></div>

    <span class="k">def</span> <span class="nf">iter_pieces</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">CorpusFnameTuple</span><span class="p">,</span> <span class="n">Piece</span><span class="p">]:</span>
        <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">fname</span><span class="p">,</span> <span class="n">piece</span> <span class="ow">in</span> <span class="n">corpus</span><span class="p">:</span>
                <span class="k">yield</span> <span class="p">(</span><span class="n">corpus_name</span><span class="p">,</span> <span class="n">fname</span><span class="p">),</span> <span class="n">piece</span>

    <span class="k">def</span> <span class="nf">load_facet_into_scores</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">facet</span><span class="p">:</span> <span class="n">AnnotationsFacet</span><span class="p">,</span>
                               <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">force</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                               <span class="n">choose</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;ask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span>
                               <span class="n">git_revision</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">key</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;detached&#39;</span><span class="p">,</span>
                               <span class="n">infer</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                               <span class="o">**</span><span class="n">cols</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="nb">int</span><span class="p">]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">(</span><span class="n">view_name</span><span class="p">):</span>
            <span class="n">result</span><span class="p">[</span><span class="n">corpus_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">corpus</span><span class="o">.</span><span class="n">load_facet_into_scores</span><span class="p">(</span><span class="n">facet</span><span class="o">=</span><span class="n">facet</span><span class="p">,</span>
                                                                <span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">,</span>
                                                                <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">,</span>
                                                                <span class="n">choose</span><span class="o">=</span><span class="n">choose</span><span class="p">,</span>
                                                                <span class="n">git_revision</span><span class="o">=</span><span class="n">git_revision</span><span class="p">,</span>
                                                                <span class="n">key</span><span class="o">=</span><span class="n">key</span><span class="p">,</span>
                                                                <span class="n">infer</span><span class="o">=</span><span class="n">infer</span><span class="p">,</span>
                                                                <span class="o">**</span><span class="n">cols</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

<div class="viewcode-block" id="Parse.load_ignored_warnings"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.load_ignored_warnings">[docs]</a>    <span class="k">def</span> <span class="nf">load_ignored_warnings</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">path</span><span class="p">:</span> <span class="nb">str</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot; Adds a filters to all loggers included in a IGNORED_WARNINGS file.</span>

<span class="sd">        Args:</span>
<span class="sd">            path: Path of the IGNORED_WARNINGS file.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="n">_</span> <span class="o">=</span> <span class="n">corpus</span><span class="o">.</span><span class="n">load_ignored_warnings</span><span class="p">(</span><span class="n">path</span><span class="p">)</span></div>

<div class="viewcode-block" id="Parse.set_view"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.set_view">[docs]</a>    <span class="k">def</span> <span class="nf">set_view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">active</span><span class="p">:</span> <span class="n">View</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">views</span><span class="p">:</span> <span class="n">View</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register one or several view_name=View pairs.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">active</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">new_name</span> <span class="o">=</span> <span class="n">active</span><span class="o">.</span><span class="n">name</span>
            <span class="k">if</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_views</span> <span class="ow">and</span> <span class="n">active</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="p">[</span><span class="n">new_name</span><span class="p">]:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;The existing view called &#39;</span><span class="si">{</span><span class="n">new_name</span><span class="si">}</span><span class="s2">&#39; has been overwritten&quot;</span><span class="p">)</span>
                <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="p">[</span><span class="n">new_name</span><span class="p">])</span>
            <span class="n">old_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="p">[</span><span class="n">old_view</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_view</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">active</span>
        <span class="k">for</span> <span class="n">view_name</span><span class="p">,</span> <span class="n">view</span> <span class="ow">in</span> <span class="n">views</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
            <span class="k">if</span> <span class="n">view</span><span class="o">.</span><span class="n">name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
                <span class="n">view</span><span class="o">.</span><span class="n">name</span> <span class="o">=</span> <span class="n">view_name</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="p">[</span><span class="n">view_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">view</span>
        <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">active</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">active</span><span class="o">.</span><span class="n">check_token</span><span class="p">(</span><span class="s1">&#39;corpus&#39;</span><span class="p">,</span> <span class="n">corpus_name</span><span class="p">):</span>
                <span class="n">corpus</span><span class="o">.</span><span class="n">set_view</span><span class="p">(</span><span class="n">active</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">view_name</span><span class="p">,</span> <span class="n">view</span> <span class="ow">in</span> <span class="n">views</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">view</span><span class="o">.</span><span class="n">check_token</span><span class="p">(</span><span class="s1">&#39;corpus&#39;</span><span class="p">,</span> <span class="n">corpus_name</span><span class="p">):</span>
                    <span class="n">corpus</span><span class="o">.</span><span class="n">set_view</span><span class="p">(</span><span class="o">**</span><span class="p">{</span><span class="n">view_name</span><span class="p">:</span> <span class="n">view</span><span class="p">})</span></div>

    <span class="k">def</span> <span class="nf">switch_view</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">,</span>
                    <span class="n">show_info</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="n">propagate</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                    <span class="p">)</span> <span class="o">-&gt;</span> <span class="kc">None</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">view_name</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="k">return</span>
        <span class="n">new_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_view</span><span class="p">(</span><span class="n">view_name</span><span class="p">)</span>
        <span class="n">old_view</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_view</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="p">[</span><span class="n">old_view</span><span class="o">.</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">old_view</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="p">[</span><span class="kc">None</span><span class="p">]</span> <span class="o">=</span> <span class="n">new_view</span>
        <span class="n">new_name</span> <span class="o">=</span> <span class="n">new_view</span><span class="o">.</span><span class="n">name</span>
        <span class="k">if</span> <span class="n">new_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="p">:</span>
            <span class="k">del</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_views</span><span class="p">[</span><span class="n">new_name</span><span class="p">])</span>
        <span class="k">if</span> <span class="n">propagate</span><span class="p">:</span>
            <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="p">:</span>
                <span class="n">active_view</span> <span class="o">=</span> <span class="n">corpus</span><span class="o">.</span><span class="n">get_view</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">active_view</span><span class="o">.</span><span class="n">name</span> <span class="o">!=</span> <span class="n">new_name</span> <span class="ow">or</span> <span class="n">active_view</span> <span class="o">!=</span> <span class="n">new_view</span><span class="p">:</span>
                    <span class="n">corpus</span><span class="o">.</span><span class="n">set_view</span><span class="p">(</span><span class="n">new_view</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">show_info</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">update_scores</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                      <span class="n">root_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                      <span class="n">folder</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span>
                      <span class="n">suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                      <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">():</span>
            <span class="n">corpus</span><span class="o">.</span><span class="n">update_scores</span><span class="p">(</span><span class="n">root_dir</span><span class="o">=</span><span class="n">root_dir</span><span class="p">,</span>
                                 <span class="n">folder</span><span class="o">=</span><span class="n">folder</span><span class="p">,</span>
                                 <span class="n">suffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">,</span>
                                 <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">)</span>

<div class="viewcode-block" id="Parse.update_tsvs_on_disk"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.update_tsvs_on_disk">[docs]</a>    <span class="k">def</span> <span class="nf">update_tsvs_on_disk</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                       <span class="n">facets</span><span class="p">:</span> <span class="n">ScoreFacets</span> <span class="o">=</span> <span class="s1">&#39;tsv&#39;</span><span class="p">,</span>
                       <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                       <span class="n">force</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                       <span class="n">choose</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;ask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span>
                       <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;</span>
<span class="sd">        Update existing TSV files corresponding to one or several facets with information freshly extracted from a parsed</span>
<span class="sd">        score, but only if the contents are identical. Otherwise, the existing TSV file is not overwritten and the</span>
<span class="sd">        differences are displayed in a log warning. The purpose is to safely update the format of existing TSV files,</span>
<span class="sd">        (for instance with respect to column order) making sure that the content doesn&#39;t change.</span>

<span class="sd">        Args:</span>
<span class="sd">            facets:</span>
<span class="sd">            view_name:</span>
<span class="sd">            force:</span>
<span class="sd">                By default, only TSV files that have already been parsed are updated. Set to True in order to</span>
<span class="sd">                force-parse for each facet one of the TSV files included in the given view, if necessary.</span>
<span class="sd">            choose:</span>

<span class="sd">        Returns:</span>
<span class="sd">            List of paths that have been overwritten.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">):</span>
            <span class="n">paths</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">corpus</span><span class="o">.</span><span class="n">update_tsvs_on_disk</span><span class="p">(</span><span class="n">facets</span><span class="o">=</span><span class="n">facets</span><span class="p">,</span>
                                                   <span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">,</span>
                                                   <span class="n">force</span><span class="o">=</span><span class="n">force</span><span class="p">,</span>
                                                   <span class="n">choose</span><span class="o">=</span><span class="n">choose</span><span class="p">))</span>
        <span class="k">return</span> <span class="n">paths</span></div>

    <span class="k">def</span> <span class="nf">_aggregate_corpus_data</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">method</span><span class="p">,</span>
                               <span class="n">view_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                               <span class="n">concatenate</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span>
                               <span class="o">**</span><span class="n">kwargs</span>
                               <span class="p">):</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">(</span><span class="n">view_name</span><span class="p">):</span>
            <span class="n">corpus_method</span><span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">corpus</span><span class="p">,</span> <span class="n">method</span><span class="p">)</span>
            <span class="n">corpus_result</span> <span class="o">=</span> <span class="n">corpus_method</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">fname</span><span class="p">,</span> <span class="n">piece_result</span> <span class="ow">in</span> <span class="n">corpus_result</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="n">result</span><span class="p">[(</span><span class="n">corpus_name</span><span class="p">,</span> <span class="n">fname</span><span class="p">)]</span> <span class="o">=</span> <span class="n">piece_result</span>
        <span class="k">if</span> <span class="n">concatenate</span><span class="p">:</span>
            <span class="n">keys</span><span class="p">,</span> <span class="n">dataframes</span> <span class="o">=</span> <span class="p">[],</span> <span class="p">[]</span>
            <span class="n">flat</span> <span class="o">=</span> <span class="n">kwargs</span><span class="p">[</span><span class="s1">&#39;flat&#39;</span><span class="p">]</span>
            <span class="k">if</span> <span class="n">flat</span><span class="p">:</span>
                <span class="n">add_index_level</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">piece_result</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">piece_result</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">add_index_level</span> <span class="o">=</span> <span class="nb">any</span><span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="n">file_dataframe_tuples</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">1</span> <span class="k">for</span> <span class="n">piece_result</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">values</span><span class="p">()</span> <span class="k">for</span> <span class="n">file_dataframe_tuples</span> <span class="ow">in</span> <span class="n">piece_result</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
            <span class="k">for</span> <span class="n">corpus_fname</span><span class="p">,</span> <span class="n">piece_result</span> <span class="ow">in</span> <span class="n">result</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                <span class="k">if</span> <span class="n">flat</span><span class="p">:</span>
                    <span class="n">n_tuples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">piece_result</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">n_tuples</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                        <span class="k">continue</span>
                    <span class="n">keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corpus_fname</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">n_tuples</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="k">if</span> <span class="n">add_index_level</span><span class="p">:</span>
                            <span class="n">file</span><span class="p">,</span> <span class="n">df</span> <span class="o">=</span> <span class="n">piece_result</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                            <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">],</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">file</span><span class="o">.</span><span class="n">rel_path</span><span class="p">])</span>
                            <span class="n">dataframes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">dataframes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">piece_result</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="n">files</span><span class="p">,</span> <span class="n">dfs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">piece_result</span><span class="p">))</span>
                        <span class="n">ix_level</span> <span class="o">=</span> <span class="p">[</span><span class="n">file</span><span class="o">.</span><span class="n">rel_path</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">]</span>
                        <span class="n">concat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">ix_level</span><span class="p">)</span>
                        <span class="n">dataframes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">concat</span><span class="p">)</span>
                <span class="k">else</span><span class="p">:</span>
                    <span class="k">for</span> <span class="n">facet</span><span class="p">,</span> <span class="n">file_dataframe_tuples</span> <span class="ow">in</span> <span class="n">piece_result</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">n_tuples</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="n">file_dataframe_tuples</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">n_tuples</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
                            <span class="k">continue</span>
                        <span class="n">keys</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">corpus_fname</span> <span class="o">+</span> <span class="p">(</span><span class="n">facet</span><span class="p">,))</span>
                        <span class="k">if</span> <span class="n">n_tuples</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">add_index_level</span><span class="p">:</span>
                                <span class="n">file</span><span class="p">,</span> <span class="n">df</span> <span class="o">=</span> <span class="n">file_dataframe_tuples</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
                                <span class="n">df</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="p">],</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="n">file</span><span class="o">.</span><span class="n">rel_path</span><span class="p">])</span>
                                <span class="n">dataframes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">dataframes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">file_dataframe_tuples</span><span class="p">[</span><span class="mi">0</span><span class="p">][</span><span class="mi">1</span><span class="p">])</span>
                        <span class="k">else</span><span class="p">:</span>
                            <span class="n">files</span><span class="p">,</span> <span class="n">dfs</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="nb">zip</span><span class="p">(</span><span class="o">*</span><span class="n">file_dataframe_tuples</span><span class="p">))</span>
                            <span class="n">ix_level</span> <span class="o">=</span> <span class="p">[</span><span class="n">file</span><span class="o">.</span><span class="n">rel_path</span> <span class="k">for</span> <span class="n">file</span> <span class="ow">in</span> <span class="n">files</span><span class="p">]</span>
                            <span class="n">concat</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dfs</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">ix_level</span><span class="p">)</span>
                            <span class="n">dataframes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">concat</span><span class="p">)</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">dataframes</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
                <span class="k">try</span><span class="p">:</span>
                    <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">dataframes</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">keys</span><span class="p">)</span>
                <span class="k">except</span> <span class="ne">ValueError</span><span class="p">:</span>
                    <span class="n">n_levels</span> <span class="o">=</span> <span class="p">[</span><span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">nlevels</span> <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">dataframes</span><span class="p">]</span>
                    <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="nb">set</span><span class="p">(</span><span class="n">n_levels</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
                        <span class="c1"># this error might come from various form label dataframes with varying numbers of column levels</span>
                        <span class="n">adapted_dataframes</span> <span class="o">=</span> <span class="p">[]</span>
                        <span class="k">for</span> <span class="n">df</span> <span class="ow">in</span> <span class="n">dataframes</span><span class="p">:</span>
                            <span class="k">if</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">nlevels</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                                <span class="n">adapted_dataframes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">df</span><span class="p">)</span>
                            <span class="k">else</span><span class="p">:</span>
                                <span class="n">loc</span> <span class="o">=</span> <span class="n">df</span><span class="o">.</span><span class="n">columns</span><span class="o">.</span><span class="n">get_loc</span><span class="p">(</span><span class="s1">&#39;form_label&#39;</span><span class="p">)</span>
                                <span class="n">adapted_dataframes</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">([</span><span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="p">:</span><span class="n">loc</span><span class="p">],</span> <span class="n">df</span><span class="o">.</span><span class="n">iloc</span><span class="p">[:,</span> <span class="n">loc</span><span class="p">:]],</span> <span class="n">keys</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;&#39;</span><span class="p">,</span> <span class="s1">&#39;a&#39;</span><span class="p">],</span> <span class="n">axis</span><span class="o">=</span><span class="mi">1</span><span class="p">))</span>
                        <span class="n">result</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">adapted_dataframes</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="n">keys</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="k">raise</span>
                <span class="n">nlevels</span> <span class="o">=</span> <span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">nlevels</span>
                <span class="n">level_names</span> <span class="o">=</span> <span class="p">[</span><span class="s1">&#39;corpus&#39;</span><span class="p">,</span> <span class="s1">&#39;fname&#39;</span><span class="p">]</span>
                <span class="k">if</span> <span class="ow">not</span> <span class="n">flat</span><span class="p">:</span>
                    <span class="n">level_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;facet&#39;</span><span class="p">)</span>
                <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">level_names</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">nlevels</span> <span class="o">-</span> <span class="mi">1</span><span class="p">:</span>
                    <span class="n">level_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;ix&#39;</span><span class="p">)</span>
                <span class="n">level_names</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s1">&#39;i&#39;</span><span class="p">)</span>
                <span class="n">result</span><span class="o">.</span><span class="n">index</span><span class="o">.</span><span class="n">rename</span><span class="p">(</span><span class="n">level_names</span><span class="p">,</span> <span class="n">inplace</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">return</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">()</span>
        <span class="k">return</span> <span class="n">result</span>



    <span class="k">def</span> <span class="nf">_get_parsed_score_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">CorpusFnameTuple</span><span class="p">,</span> <span class="n">FileList</span><span class="p">]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">):</span>
            <span class="n">fname2files</span> <span class="o">=</span> <span class="n">corpus</span><span class="o">.</span><span class="n">get_files</span><span class="p">(</span><span class="s1">&#39;scores&#39;</span><span class="p">,</span> <span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">,</span> <span class="n">unparsed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">result</span><span class="p">[</span><span class="n">corpus_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fname2files</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="p">[])</span>
        <span class="k">return</span> <span class="n">result</span>


    <span class="k">def</span> <span class="nf">_get_unparsed_score_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">CorpusFnameTuple</span><span class="p">,</span> <span class="n">FileList</span><span class="p">]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">):</span>
            <span class="n">fname2files</span> <span class="o">=</span> <span class="n">corpus</span><span class="o">.</span><span class="n">get_files</span><span class="p">(</span><span class="s1">&#39;scores&#39;</span><span class="p">,</span> <span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">,</span> <span class="n">parsed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="n">result</span><span class="p">[</span><span class="n">corpus_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fname2files</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="p">[])</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_get_parsed_tsv_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">flat</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">CorpusFnameTuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">FileDict</span><span class="p">,</span> <span class="n">FileList</span><span class="p">]]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">):</span>
            <span class="n">fname2files</span> <span class="o">=</span> <span class="n">corpus</span><span class="o">.</span><span class="n">get_files</span><span class="p">(</span><span class="s1">&#39;tsv&#39;</span><span class="p">,</span> <span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">,</span> <span class="n">unparsed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">flat</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">corpus_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fname2files</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="p">[])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dd</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">fname</span><span class="p">,</span> <span class="n">typ2files</span> <span class="ow">in</span> <span class="n">fname2files</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">typ</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">typ2files</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">dd</span><span class="p">[</span><span class="n">typ</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
                <span class="n">result</span><span class="p">[</span><span class="n">corpus_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dd</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>

    <span class="k">def</span> <span class="nf">_get_unparsed_tsv_files</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">flat</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="n">CorpusFnameTuple</span><span class="p">,</span> <span class="n">Union</span><span class="p">[</span><span class="n">FileDict</span><span class="p">,</span> <span class="n">FileList</span><span class="p">]]:</span>
        <span class="n">result</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">):</span>
            <span class="n">fname2files</span> <span class="o">=</span> <span class="n">corpus</span><span class="o">.</span><span class="n">get_files</span><span class="p">(</span><span class="s1">&#39;tsv&#39;</span><span class="p">,</span> <span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">,</span> <span class="n">parsed</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">flat</span><span class="o">=</span><span class="n">flat</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">flat</span><span class="p">:</span>
                <span class="n">result</span><span class="p">[</span><span class="n">corpus_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">fname2files</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="p">[])</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">dd</span> <span class="o">=</span> <span class="n">defaultdict</span><span class="p">(</span><span class="nb">list</span><span class="p">)</span>
                <span class="k">for</span> <span class="n">fname</span><span class="p">,</span> <span class="n">typ2files</span> <span class="ow">in</span> <span class="n">fname2files</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                    <span class="k">for</span> <span class="n">typ</span><span class="p">,</span> <span class="n">files</span> <span class="ow">in</span> <span class="n">typ2files</span><span class="o">.</span><span class="n">items</span><span class="p">():</span>
                        <span class="n">dd</span><span class="p">[</span><span class="n">typ</span><span class="p">]</span><span class="o">.</span><span class="n">extend</span><span class="p">(</span><span class="n">files</span><span class="p">)</span>
                <span class="n">result</span><span class="p">[</span><span class="n">corpus_name</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">(</span><span class="n">dd</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">result</span>


    <span class="k">def</span> <span class="fm">__getattr__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view_name</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">View</span><span class="p">:</span>
        <span class="k">if</span> <span class="n">view_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">view_names</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">view_name</span> <span class="o">!=</span> <span class="bp">self</span><span class="o">.</span><span class="n">view_name</span><span class="p">:</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">switch_view</span><span class="p">(</span><span class="n">view_name</span><span class="p">,</span> <span class="n">show_info</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
            <span class="k">return</span> <span class="bp">self</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;&#39;</span><span class="si">{</span><span class="n">view_name</span><span class="si">}</span><span class="s2">&#39; is not an existing view. Use _.get_view(&#39;</span><span class="si">{</span><span class="n">view_name</span><span class="si">}</span><span class="s2">&#39;) to create it.&quot;</span><span class="p">)</span>


<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#     def count_annotation_layers(self, keys=None, which=&#39;attached&#39;, per_key=False):</span>
<span class="c1">#         &quot;&quot;&quot; Counts the labels for each annotation layer defined as (staff, voice, harmony_layer).</span>
<span class="c1">#         By default, only labels attached to a score are counted.</span>
<span class="c1">#</span>
<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         keys : :obj:`str` or :obj:`~collections.abc.Collection`, optional</span>
<span class="c1">#             Key(s) for which to count annotation layers.  By default, all keys are selected.</span>
<span class="c1">#         which : {&#39;attached&#39;, &#39;detached&#39;, &#39;tsv&#39;}, optional</span>
<span class="c1">#             &#39;attached&#39;: Counts layers from annotations attached to a score.</span>
<span class="c1">#             &#39;detached&#39;: Counts layers from annotations that are in a Score object, but detached from the score.</span>
<span class="c1">#             &#39;tsv&#39;: Counts layers from Annotation objects that have been loaded from or into annotation tables.</span>
<span class="c1">#         per_key : :obj:`bool`, optional</span>
<span class="c1">#             If set to True, the results are returned as a dict {key: Counter}, otherwise the counts are summed up in one Counter.</span>
<span class="c1">#             If ``which=&#39;detached&#39;``, the keys are keys from Score objects, otherwise they are keys from this Parse object.</span>
<span class="c1">#</span>
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         :obj:`dict` or :obj:`collections.Counter`</span>
<span class="c1">#             By default, the function returns a Counter of labels for every annotation layer (staff, voice, harmony_layer)</span>
<span class="c1">#             If ``per_key`` is set to True, a dictionary {key: Counter} is returned, separating the counts.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         res_dict = defaultdict(Counter)</span>
<span class="c1">#</span>
<span class="c1">#         if which == &#39;detached&#39;:</span>
<span class="c1">#             for id in self._iterids(keys, only_detached_annotations=True):</span>
<span class="c1">#                 for key, annotations in self._parsed_mscx[id]._detached_annotations.items():</span>
<span class="c1">#                     if key != &#39;annotations&#39;:</span>
<span class="c1">#                         _, layers = annotations.annotation_layers</span>
<span class="c1">#                         layers_dict = {tuple(None if pd.isnull(e) else e for e in t): count for t, count in</span>
<span class="c1">#                                        layers.to_dict().items()}</span>
<span class="c1">#                         res_dict[key].update(layers_dict)</span>
<span class="c1">#         elif which in [&#39;attached&#39;, &#39;tsv&#39;]:</span>
<span class="c1">#             for key, i in self._iterids(keys):</span>
<span class="c1">#                 if (key, i) in self._annotations:</span>
<span class="c1">#                     ext = self.fexts[key][i]</span>
<span class="c1">#                     if (which == &#39;attached&#39; and ext == &#39;.mscx&#39;) or (which == &#39;tsv&#39; and ext != &#39;.mscx&#39;):</span>
<span class="c1">#                         _, layers = self._annotations[(key, i)].annotation_layers</span>
<span class="c1">#                         layers_dict = {tuple(None if pd.isnull(e) else e for e in t): count for t, count in</span>
<span class="c1">#                                        layers.to_dict().items()}</span>
<span class="c1">#                         res_dict[key].update(layers_dict)</span>
<span class="c1">#         else:</span>
<span class="c1">#             self.logger.error(f&quot;Parameter &#39;which&#39; needs to be one of {{&#39;attached&#39;, &#39;detached&#39;, &#39;tsv&#39;}}, not {which}.&quot;)</span>
<span class="c1">#             return {} if per_key else pd.Series()</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#         def make_series(counts):</span>
<span class="c1">#             if len(counts) == 0:</span>
<span class="c1">#                 return pd.Series()</span>
<span class="c1">#             data = counts.values()</span>
<span class="c1">#             ks = list(counts.keys())</span>
<span class="c1">#             #levels = len(ks[0])</span>
<span class="c1">#             names = [&#39;staff&#39;, &#39;voice&#39;, &#39;harmony_layer&#39;, &#39;color&#39;] #&lt;[:levels]</span>
<span class="c1">#             ix = pd.MultiIndex.from_tuples(ks, names=names)</span>
<span class="c1">#             return pd.Series(data, ix)</span>
<span class="c1">#</span>
<span class="c1">#         if per_key:</span>
<span class="c1">#             res = {k: make_series(v) for k, v in res_dict.items()}</span>
<span class="c1">#         else:</span>
<span class="c1">#             res = make_series(sum(res_dict.values(), Counter()))</span>
<span class="c1">#         if len(res) == 0:</span>
<span class="c1">#             self.logger.info(&quot;No annotations found. Maybe no scores have been parsed using parse_scores()?&quot;)</span>
<span class="c1">#         return res</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#     def count_labels(self, keys=None, per_key=False):</span>
<span class="c1">#         &quot;&quot;&quot; Count label types.</span>
<span class="c1">#</span>
<span class="c1">#         Parameters</span>
<span class="c1">#         ----------</span>
<span class="c1">#         keys : :obj:`str` or :obj:`~collections.abc.Collection`, optional</span>
<span class="c1">#             Key(s) for which to count label types.  By default, all keys are selected.</span>
<span class="c1">#         per_key : :obj:`bool`, optional</span>
<span class="c1">#             If set to True, the results are returned as a dict {key: Counter},</span>
<span class="c1">#             otherwise the counts are summed up in one Counter.</span>
<span class="c1">#</span>
<span class="c1">#         Returns</span>
<span class="c1">#         -------</span>
<span class="c1">#         :obj:`dict` or :obj:`collections.Counter`</span>
<span class="c1">#             By default, the function returns a Counter of label types.</span>
<span class="c1">#             If ``per_key`` is set to True, a dictionary {key: Counter} is returned, separating the counts.</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         annotated = [id for id in self._iterids(keys) if id in self._annotations]</span>
<span class="c1">#         res_dict = defaultdict(Counter)</span>
<span class="c1">#         for key, i in annotated:</span>
<span class="c1">#             res_dict[key].update(self._annotations[(key, i)].harmony_layer_counts)</span>
<span class="c1">#         if len(res_dict) == 0:</span>
<span class="c1">#             if len(self._parsed_mscx) == 0:</span>
<span class="c1">#                 self.logger.error(&quot;No scores have been parsed so far. Use parse_scores().&quot;)</span>
<span class="c1">#             else:</span>
<span class="c1">#                 self.logger.info(&quot;None of the scores contain annotations.&quot;)</span>
<span class="c1">#         if per_key:</span>
<span class="c1">#             return {k: dict(v) for k, v in res_dict.items()}</span>
<span class="c1">#         return dict(sum(res_dict.values(), Counter()))</span>
<span class="c1">#</span>

<div class="viewcode-block" id="Parse.detach_labels"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.detach_labels">[docs]</a>    <span class="k">def</span> <span class="nf">detach_labels</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">keys</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">annotation_key</span><span class="o">=</span><span class="s1">&#39;detached&#39;</span><span class="p">,</span> <span class="n">staff</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">voice</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">harmony_layer</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="kc">True</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Calls :py:meth:`Score.detach_labels&lt;ms3.score.Score.detach_labels` on every parsed score with key ``key``.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">assert</span> <span class="n">annotation_key</span> <span class="o">!=</span> <span class="s1">&#39;annotations&#39;</span><span class="p">,</span> <span class="s2">&quot;The key &#39;annotations&#39; is reserved, please choose a different one.&quot;</span>
        <span class="n">ids</span> <span class="o">=</span> <span class="nb">list</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">_iterids</span><span class="p">(</span><span class="n">keys</span><span class="p">,</span> <span class="n">only_attached_annotations</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>
        <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">ids</span><span class="p">)</span> <span class="o">==</span> <span class="mi">0</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Selection did not contain scores with labels: keys = &#39;</span><span class="si">{</span><span class="n">keys</span><span class="si">}</span><span class="s2">&#39;&quot;</span><span class="p">)</span>
        <span class="k">for</span> <span class="nb">id</span> <span class="ow">in</span> <span class="n">ids</span><span class="p">:</span>
            <span class="n">score</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_parsed_mscx</span><span class="p">[</span><span class="nb">id</span><span class="p">]</span>
            <span class="k">try</span><span class="p">:</span>
                <span class="n">score</span><span class="o">.</span><span class="n">detach_labels</span><span class="p">(</span><span class="n">key</span><span class="o">=</span><span class="n">annotation_key</span><span class="p">,</span> <span class="n">staff</span><span class="o">=</span><span class="n">staff</span><span class="p">,</span> <span class="n">voice</span><span class="o">=</span><span class="n">voice</span><span class="p">,</span> <span class="n">harmony_layer</span><span class="o">=</span><span class="n">harmony_layer</span><span class="p">,</span> <span class="n">delete</span><span class="o">=</span><span class="n">delete</span><span class="p">)</span>
            <span class="k">except</span><span class="p">:</span>
                <span class="n">score</span><span class="o">.</span><span class="n">logger</span><span class="o">.</span><span class="n">error</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Detaching labels failed with the following error:</span><span class="se">\n</span><span class="si">{</span><span class="n">sys</span><span class="o">.</span><span class="n">exc_info</span><span class="p">()[</span><span class="mi">1</span><span class="p">]</span><span class="si">}</span><span class="s2">&quot;</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_collect_annotations_objects_references</span><span class="p">(</span><span class="n">ids</span><span class="o">=</span><span class="n">ids</span><span class="p">)</span></div>



    <span class="k">def</span> <span class="nf">score_metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="n">metadata_dfs</span> <span class="o">=</span> <span class="p">{</span><span class="n">corpus_name</span><span class="p">:</span> <span class="n">corpus</span><span class="o">.</span><span class="n">score_metadata</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">)</span> <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">)}</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">metadata_dfs</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">keys</span><span class="o">=</span><span class="n">metadata_dfs</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;corpus&#39;</span><span class="p">,</span> <span class="s1">&#39;fname&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">metadata</span>

    <span class="k">def</span> <span class="nf">metadata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                 <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                 <span class="n">choose</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;ask&#39;</span><span class="p">]]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="n">metadata_dfs</span> <span class="o">=</span> <span class="p">{</span><span class="n">corpus_name</span><span class="p">:</span> <span class="n">corpus</span><span class="o">.</span><span class="n">metadata</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">,</span> <span class="n">choose</span><span class="o">=</span><span class="n">choose</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">)}</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">metadata_dfs</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">keys</span><span class="o">=</span><span class="n">metadata_dfs</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;corpus&#39;</span><span class="p">,</span> <span class="s1">&#39;fname&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">metadata</span>

<div class="viewcode-block" id="Parse.metadata_tsv"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.metadata_tsv">[docs]</a>    <span class="k">def</span> <span class="nf">metadata_tsv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">pd</span><span class="o">.</span><span class="n">DataFrame</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Concatenates the &#39;metadata.tsv&#39; (as they come) files for all corpora with a [corpus, fname] MultiIndex. If</span>
<span class="sd">        you need metadata that filters out fnames according to the current view, use :meth:`metadata`.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">metadata_dfs</span> <span class="o">=</span> <span class="p">{</span><span class="n">corpus_name</span><span class="p">:</span> <span class="n">enforce_fname_index_for_metadata</span><span class="p">(</span><span class="n">corpus</span><span class="o">.</span><span class="n">metadata_tsv</span><span class="p">)</span>
                        <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">)</span>
                        <span class="k">if</span> <span class="n">corpus</span><span class="o">.</span><span class="n">metadata_tsv</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span>
                        <span class="p">}</span>
        <span class="n">metadata</span> <span class="o">=</span> <span class="n">pd</span><span class="o">.</span><span class="n">concat</span><span class="p">(</span><span class="n">metadata_dfs</span><span class="o">.</span><span class="n">values</span><span class="p">(),</span> <span class="n">keys</span><span class="o">=</span><span class="n">metadata_dfs</span><span class="o">.</span><span class="n">keys</span><span class="p">(),</span> <span class="n">names</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;corpus&#39;</span><span class="p">,</span> <span class="s1">&#39;fname&#39;</span><span class="p">])</span>
        <span class="k">return</span> <span class="n">metadata</span></div>



<div class="viewcode-block" id="Parse.store_extracted_facets"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.store_extracted_facets">[docs]</a>    <span class="k">def</span> <span class="nf">store_extracted_facets</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                               <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">root_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                               <span class="n">measures_folder</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">measures_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                               <span class="n">notes_folder</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">notes_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                               <span class="n">rests_folder</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">rests_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                               <span class="n">notes_and_rests_folder</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">notes_and_rests_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                               <span class="n">labels_folder</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">labels_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                               <span class="n">expanded_folder</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">expanded_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                               <span class="n">form_labels_folder</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">form_labels_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                               <span class="n">cadences_folder</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">cadences_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                               <span class="n">events_folder</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">events_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                               <span class="n">chords_folder</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">chords_suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                               <span class="n">metadata_suffix</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span> <span class="n">markdown</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                               <span class="n">simulate</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                               <span class="n">unfold</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                               <span class="n">interval_index</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                               <span class="n">silence_label_warnings</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;  Store facets extracted from parsed scores as TSV files.</span>

<span class="sd">        Args:</span>
<span class="sd">            view_name:</span>
<span class="sd">            root_dir:</span>
<span class="sd">                (&#39;measures&#39;, &#39;notes&#39;, &#39;rests&#39;, &#39;notes_and_rests&#39;, &#39;labels&#39;, &#39;expanded&#39;, &#39;form_labels&#39;, &#39;cadences&#39;, &#39;events&#39;, &#39;chords&#39;)</span>

<span class="sd">            measures_folder, notes_folder, rests_folder, notes_and_rests_folder, labels_folder, expanded_folder, form_labels_folder, cadences_folder, events_folder, chords_folder:</span>
<span class="sd">                Specify directory where to store the corresponding TSV files.</span>
<span class="sd">            measures_suffix, notes_suffix, rests_suffix, notes_and_rests_suffix, labels_suffix, expanded_suffix, form_labels_suffix, cadences_suffix, events_suffix, chords_suffix:</span>
<span class="sd">                Optionally specify suffixes appended to the TSVs&#39; file names. If ``unfold=True`` the suffixes default to ``_unfolded``.</span>
<span class="sd">            metadata_suffix:</span>
<span class="sd">                Specify a suffix to update the &#39;metadata{suffix}.tsv&#39; file for each corpus. For the main file, pass &#39;&#39;</span>
<span class="sd">            markdown:</span>
<span class="sd">                By default, when ``metadata_path`` is specified, a markdown file called ``README.md`` containing</span>
<span class="sd">                the columns [file_name, measures, labels, standard, annotators, reviewers] is created. If it exists already,</span>
<span class="sd">                this table will be appended or overwritten after the heading ``# Overview``.</span>
<span class="sd">            simulate:</span>
<span class="sd">            unfold:</span>
<span class="sd">                By default, repetitions are not unfolded. Pass True to duplicate values so that they correspond to a full</span>
<span class="sd">                playthrough, including correct positioning of first and second endings.</span>
<span class="sd">            interval_index:</span>
<span class="sd">            silence_label_warnings:</span>

<span class="sd">        Returns:</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">):</span>
            <span class="n">corpus</span><span class="o">.</span><span class="n">store_extracted_facets</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">,</span> <span class="n">root_dir</span><span class="o">=</span><span class="n">root_dir</span><span class="p">,</span> <span class="n">measures_folder</span><span class="o">=</span><span class="n">measures_folder</span><span class="p">,</span> <span class="n">measures_suffix</span><span class="o">=</span><span class="n">measures_suffix</span><span class="p">,</span> <span class="n">notes_folder</span><span class="o">=</span><span class="n">notes_folder</span><span class="p">,</span> <span class="n">notes_suffix</span><span class="o">=</span><span class="n">notes_suffix</span><span class="p">,</span>
                                          <span class="n">rests_folder</span><span class="o">=</span><span class="n">rests_folder</span><span class="p">,</span> <span class="n">rests_suffix</span><span class="o">=</span><span class="n">rests_suffix</span><span class="p">,</span> <span class="n">notes_and_rests_folder</span><span class="o">=</span><span class="n">notes_and_rests_folder</span><span class="p">,</span>
                                          <span class="n">notes_and_rests_suffix</span><span class="o">=</span><span class="n">notes_and_rests_suffix</span><span class="p">,</span> <span class="n">labels_folder</span><span class="o">=</span><span class="n">labels_folder</span><span class="p">,</span> <span class="n">labels_suffix</span><span class="o">=</span><span class="n">labels_suffix</span><span class="p">,</span> <span class="n">expanded_folder</span><span class="o">=</span><span class="n">expanded_folder</span><span class="p">,</span>
                                          <span class="n">expanded_suffix</span><span class="o">=</span><span class="n">expanded_suffix</span><span class="p">,</span> <span class="n">form_labels_folder</span><span class="o">=</span><span class="n">form_labels_folder</span><span class="p">,</span> <span class="n">form_labels_suffix</span><span class="o">=</span><span class="n">form_labels_suffix</span><span class="p">,</span>
                                          <span class="n">cadences_folder</span><span class="o">=</span><span class="n">cadences_folder</span><span class="p">,</span> <span class="n">cadences_suffix</span><span class="o">=</span><span class="n">cadences_suffix</span><span class="p">,</span> <span class="n">events_folder</span><span class="o">=</span><span class="n">events_folder</span><span class="p">,</span> <span class="n">events_suffix</span><span class="o">=</span><span class="n">events_suffix</span><span class="p">,</span>
                                          <span class="n">chords_folder</span><span class="o">=</span><span class="n">chords_folder</span><span class="p">,</span> <span class="n">chords_suffix</span><span class="o">=</span><span class="n">chords_suffix</span><span class="p">,</span> <span class="n">metadata_suffix</span><span class="o">=</span><span class="n">metadata_suffix</span><span class="p">,</span> <span class="n">markdown</span><span class="o">=</span><span class="n">markdown</span><span class="p">,</span> <span class="n">simulate</span><span class="o">=</span><span class="n">simulate</span><span class="p">,</span>
                                          <span class="n">unfold</span><span class="o">=</span><span class="n">unfold</span><span class="p">,</span> <span class="n">interval_index</span><span class="o">=</span><span class="n">interval_index</span><span class="p">,</span> <span class="n">silence_label_warnings</span><span class="o">=</span><span class="n">silence_label_warnings</span><span class="p">)</span></div>

<div class="viewcode-block" id="Parse.store_parsed_scores"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.store_parsed_scores">[docs]</a>    <span class="k">def</span> <span class="nf">store_parsed_scores</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                            <span class="n">view_name</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">only_changed</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                            <span class="n">root_dir</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                            <span class="n">folder</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;.&#39;</span><span class="p">,</span>
                            <span class="n">suffix</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="s1">&#39;&#39;</span><span class="p">,</span>
                            <span class="n">overwrite</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
                            <span class="n">simulate</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot; Stores all parsed scores under this view as MuseScore 3 files.</span>

<span class="sd">        Args:</span>
<span class="sd">            view_name:</span>
<span class="sd">            only_changed:</span>
<span class="sd">                By default, only scores that have been modified since parsing are written. Set to False to store</span>
<span class="sd">                all scores regardless.</span>
<span class="sd">            root_dir:</span>
<span class="sd">            folder:</span>
<span class="sd">            suffix: Suffix to append to the original file name.</span>
<span class="sd">            overwrite: Pass True to overwrite existing files.</span>
<span class="sd">            simulate: Set to True if no files are to be written.</span>

<span class="sd">        Returns:</span>
<span class="sd">            Paths of the stored files.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">paths</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">(</span><span class="n">view_name</span><span class="p">):</span>
            <span class="n">paths</span><span class="p">[</span><span class="n">corpus_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">corpus</span><span class="o">.</span><span class="n">store_parsed_scores</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">,</span>
                                                    <span class="n">only_changed</span><span class="o">=</span><span class="n">only_changed</span><span class="p">,</span>
                                                    <span class="n">root_dir</span><span class="o">=</span><span class="n">root_dir</span><span class="p">,</span>
                                                    <span class="n">folder</span><span class="o">=</span><span class="n">folder</span><span class="p">,</span>
                                                    <span class="n">suffix</span><span class="o">=</span><span class="n">suffix</span><span class="p">,</span>
                                                    <span class="n">overwrite</span><span class="o">=</span><span class="n">overwrite</span><span class="p">,</span>
                                                    <span class="n">simulate</span><span class="o">=</span><span class="n">simulate</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">paths</span></div>

<div class="viewcode-block" id="Parse.parse"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.parse">[docs]</a>    <span class="k">def</span> <span class="nf">parse</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">view_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">only_new</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> <span class="n">labels_cfg</span><span class="o">=</span><span class="p">{},</span> <span class="n">cols</span><span class="o">=</span><span class="p">{},</span> <span class="n">infer_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Shorthand for executing parse_scores and parse_tsv at a time.</span>
<span class="sd">        Args:</span>
<span class="sd">            view_name:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parse_scores</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span> <span class="n">only_new</span><span class="o">=</span><span class="n">only_new</span><span class="p">,</span> <span class="n">labels_cfg</span><span class="o">=</span><span class="n">labels_cfg</span><span class="p">,</span> <span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">parse_tsv</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">,</span> <span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span> <span class="n">cols</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span> <span class="n">infer_types</span><span class="o">=</span><span class="n">infer_types</span><span class="p">,</span> <span class="n">only_new</span><span class="o">=</span><span class="n">only_new</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>

<div class="viewcode-block" id="Parse.parse_mscx"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.parse_mscx">[docs]</a>    <span class="k">def</span> <span class="nf">parse_mscx</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="o">*</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Deprecated method. Replaced by :meth:`parse_scores`.&quot;&quot;&quot;</span>
        <span class="k">raise</span> <span class="ne">AttributeError</span><span class="p">(</span><span class="sa">f</span><span class="s2">&quot;Method not in use any more. Use Parse.parse_scores().&quot;</span><span class="p">)</span></div>

<div class="viewcode-block" id="Parse.parse_scores"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.parse_scores">[docs]</a>    <span class="k">def</span> <span class="nf">parse_scores</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                     <span class="n">level</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">parallel</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="n">only_new</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
                     <span class="n">labels_cfg</span><span class="p">:</span> <span class="nb">dict</span> <span class="o">=</span> <span class="p">{},</span>
                     <span class="n">view_name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
                     <span class="n">choose</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;ask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Parse MuseScore 3 files (MSCX or MSCZ) and store the resulting read-only Score objects. If they need</span>
<span class="sd">        to be writeable, e.g. for removing or adding labels, pass ``parallel=False`` which takes longer but prevents</span>
<span class="sd">        having to re-parse at a later point.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keys : :obj:`str` or :obj:`~collections.abc.Collection`, optional</span>
<span class="sd">            For which key(s) to parse all MSCX files.</span>
<span class="sd">        ids : :obj:`~collections.abc.Collection`</span>
<span class="sd">            To parse only particular files, pass their IDs. ``keys`` and ``fexts`` are ignored in this case.</span>
<span class="sd">        level : {&#39;W&#39;, &#39;D&#39;, &#39;I&#39;, &#39;E&#39;, &#39;C&#39;, &#39;WARNING&#39;, &#39;DEBUG&#39;, &#39;INFO&#39;, &#39;ERROR&#39;, &#39;CRITICAL&#39;}, optional</span>
<span class="sd">            Pass a level name for which (and above which) you want to see log records.</span>
<span class="sd">        parallel : :obj:`bool`, optional</span>
<span class="sd">            Defaults to True, meaning that all CPU cores are used simultaneously to speed up the parsing. It implies</span>
<span class="sd">            that the resulting Score objects are in read-only mode and that you might not be able to use the computer</span>
<span class="sd">            during parsing. Pass False to parse one score after the other, which uses more memory but will allow</span>
<span class="sd">            making changes to the scores.</span>
<span class="sd">        only_new : :obj:`bool`, optional</span>
<span class="sd">            By default, score which already have been parsed, are not parsed again. Pass False to parse them, too.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">change_logger_cfg</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">):</span>
            <span class="n">corpus</span><span class="o">.</span><span class="n">parse_scores</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">,</span>
                                <span class="n">parallel</span><span class="o">=</span><span class="n">parallel</span><span class="p">,</span>
                                <span class="n">only_new</span><span class="o">=</span><span class="n">only_new</span><span class="p">,</span>
                                <span class="n">labels_cfg</span><span class="o">=</span><span class="n">labels_cfg</span><span class="p">,</span>
                                <span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">,</span>
                                <span class="n">choose</span><span class="o">=</span><span class="n">choose</span><span class="p">)</span></div>



<div class="viewcode-block" id="Parse.parse_tsv"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.parse_tsv">[docs]</a>    <span class="k">def</span> <span class="nf">parse_tsv</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span>
                  <span class="n">view_name</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">cols</span><span class="o">=</span><span class="p">{},</span>
                  <span class="n">infer_types</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                  <span class="n">only_new</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
                  <span class="n">choose</span><span class="p">:</span> <span class="n">Literal</span><span class="p">[</span><span class="s1">&#39;all&#39;</span><span class="p">,</span> <span class="s1">&#39;auto&#39;</span><span class="p">,</span> <span class="s1">&#39;ask&#39;</span><span class="p">]</span> <span class="o">=</span> <span class="s1">&#39;all&#39;</span><span class="p">,</span>
                  <span class="o">**</span><span class="n">kwargs</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot; Parse TSV files (or other value-separated files such as CSV) to be able to do something with them.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        keys : :obj:`str` or :obj:`~collections.abc.Collection`, optional</span>
<span class="sd">            Key(s) for which to parse all non-MSCX files.  By default, all keys are selected.</span>
<span class="sd">        ids : :obj:`~collections.abc.Collection`</span>
<span class="sd">            To parse only particular files, pass there IDs. ``keys`` and ``fexts`` are ignored in this case.</span>
<span class="sd">        fexts :  :obj:`str` or :obj:`~collections.abc.Collection`, optional</span>
<span class="sd">            If you want to parse only files with one or several particular file extension(s), pass the extension(s)</span>
<span class="sd">        cols : :obj:`dict`, optional</span>
<span class="sd">            By default, if a column called ``&#39;label&#39;`` is found, the TSV is treated as an annotation table and turned into</span>
<span class="sd">            an Annotations object. Pass one or several column name(s) to treat *them* as label columns instead. If you</span>
<span class="sd">            pass ``{}`` or no label column is found, the TSV is parsed as a &quot;normal&quot; table, i.e. a DataFrame.</span>
<span class="sd">        infer_types : :obj:`dict`, optional</span>
<span class="sd">            To recognize one or several custom label type(s), pass ``{name: regEx}``.</span>
<span class="sd">        level : {&#39;W&#39;, &#39;D&#39;, &#39;I&#39;, &#39;E&#39;, &#39;C&#39;, &#39;WARNING&#39;, &#39;DEBUG&#39;, &#39;INFO&#39;, &#39;ERROR&#39;, &#39;CRITICAL&#39;}, optional</span>
<span class="sd">            Pass a level name for which (and above which) you want to see log records.</span>
<span class="sd">        **kwargs:</span>
<span class="sd">            Arguments for :py:meth:`pandas.DataFrame.to_csv`. Defaults to ``{&#39;sep&#39;: &#39;\t&#39;, &#39;index&#39;: False}``. In particular,</span>
<span class="sd">            you might want to update the default dictionaries for ``dtypes`` and ``converters`` used in :py:func:`load_tsv`.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        None</span>

<span class="sd">        Args:</span>
<span class="sd">            only_new:</span>
<span class="sd">            view_name:</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">level</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">change_logger_cfg</span><span class="p">(</span><span class="n">level</span><span class="o">=</span><span class="n">level</span><span class="p">)</span>
        <span class="k">for</span> <span class="n">corpus_name</span><span class="p">,</span> <span class="n">corpus</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">iter_corpora</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">):</span>
            <span class="n">corpus</span><span class="o">.</span><span class="n">parse_tsv</span><span class="p">(</span><span class="n">view_name</span><span class="o">=</span><span class="n">view_name</span><span class="p">,</span>
                             <span class="n">cols</span><span class="o">=</span><span class="n">cols</span><span class="p">,</span>
                             <span class="n">infer_types</span><span class="o">=</span><span class="n">infer_types</span><span class="p">,</span>
                             <span class="n">only_new</span><span class="o">=</span><span class="n">only_new</span><span class="p">,</span>
                             <span class="n">choose</span><span class="o">=</span><span class="n">choose</span><span class="p">,</span>
                             <span class="o">**</span><span class="n">kwargs</span><span class="p">)</span></div>


    <span class="c1"># def _parse_tsv_from_git_revision(self, tsv_id, revision_specifier):</span>
    <span class="c1">#     &quot;&quot;&quot; Takes the ID of an annotation table, and parses the same file&#39;s previous version at ``revision_specifier``.</span>
    <span class="c1">#</span>
    <span class="c1">#     Parameters</span>
    <span class="c1">#     ----------</span>
    <span class="c1">#     tsv_id</span>
    <span class="c1">#         ID of the TSV file containing an annotation table, for which to parse a previous version.</span>
    <span class="c1">#     revision_specifier : :obj:`str`</span>
    <span class="c1">#         String used by git.Repo.commit() to find the desired git revision.</span>
    <span class="c1">#         Can be a long or short SHA, git tag, branch name, or relative specifier such as &#39;HEAD~1&#39;.</span>
    <span class="c1">#</span>
    <span class="c1">#     Returns</span>
    <span class="c1">#     -------</span>
    <span class="c1">#     ID</span>
    <span class="c1">#         (key, i) of the newly added annotation table.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     key, i = tsv_id</span>
    <span class="c1">#     corpus_path = self.corpus_paths[key]</span>
    <span class="c1">#     try:</span>
    <span class="c1">#         repo = Repo(corpus_path, search_parent_directories=True)</span>
    <span class="c1">#     except InvalidGitRepositoryError:</span>
    <span class="c1">#         self.logger.error(f&quot;{corpus_path} seems not to be (part of) a git repository.&quot;)</span>
    <span class="c1">#         return</span>
    <span class="c1">#     try:</span>
    <span class="c1">#         git_repo = repo.remote(&quot;origin&quot;).url</span>
    <span class="c1">#     except ValueError:</span>
    <span class="c1">#         git_repo = os.path.basename()</span>
    <span class="c1">#     try:</span>
    <span class="c1">#         commit = repo.commit(revision_specifier)</span>
    <span class="c1">#         commit_sha = commit.hexsha</span>
    <span class="c1">#         short_sha = commit_sha[:7]</span>
    <span class="c1">#         commit_info = f&quot;{short_sha} with message &#39;{commit.message}&#39;&quot;</span>
    <span class="c1">#     except BadName:</span>
    <span class="c1">#         self.logger.error(f&quot;{revision_specifier} does not resolve to a commit for repo {git_repo}.&quot;)</span>
    <span class="c1">#         return</span>
    <span class="c1">#     tsv_type = self._tsv_types[tsv_id]</span>
    <span class="c1">#     tsv_path = self.full_paths[key][i]</span>
    <span class="c1">#     rel_path = os.path.relpath(tsv_path, corpus_path)</span>
    <span class="c1">#     new_directory = os.path.join(corpus_path, short_sha)</span>
    <span class="c1">#     new_path = os.path.join(new_directory, self.files[key][i])</span>
    <span class="c1">#     if new_path in self.full_paths[key]:</span>
    <span class="c1">#         existing_i = self.full_paths[key].index(new_path)</span>
    <span class="c1">#         existing_tsv_type = self._tsv_types[(key, existing_i)]</span>
    <span class="c1">#         if tsv_type == existing_tsv_type:</span>
    <span class="c1">#             self.logger.error(f&quot;Had already loaded a {tsv_type} table for commit {commit_info} of repo {git_repo}.&quot;)</span>
    <span class="c1">#             return</span>
    <span class="c1">#     if not tsv_type in (&#39;labels&#39;, &#39;expanded&#39;):</span>
    <span class="c1">#         raise NotImplementedError(f&quot;Currently, only annotations are to be loaded from a git revision but {rel_path} is a {tsv_type}.&quot;)</span>
    <span class="c1">#     try:</span>
    <span class="c1">#         targetfile = commit.tree / rel_path</span>
    <span class="c1">#     except KeyError:</span>
    <span class="c1">#         # if the file was not found, try and see if at the time of the git revision the folder was still called &#39;harmonies&#39;</span>
    <span class="c1">#         if tsv_type == &#39;expanded&#39;:</span>
    <span class="c1">#             folder, tsv_name = os.path.split(rel_path)</span>
    <span class="c1">#             if folder != &#39;harmonies&#39;:</span>
    <span class="c1">#                 old_rel_path = os.path.join(&#39;harmonies&#39;, tsv_name)</span>
    <span class="c1">#                 try:</span>
    <span class="c1">#                     targetfile = commit.tree / old_rel_path</span>
    <span class="c1">#                     self.logger.debug(f&quot;{rel_path} did not exist at commit {commit_info}, using {old_rel_path} instead.&quot;)</span>
    <span class="c1">#                     rel_path = old_rel_path</span>
    <span class="c1">#                 except KeyError:</span>
    <span class="c1">#                     self.logger.error(f&quot;Neither {rel_path} nor its older version {old_rel_path} existed at commit {commit_info}.&quot;)</span>
    <span class="c1">#                     return</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             self.logger.error(f&quot;{rel_path} did not exist at commit {commit_info}.&quot;)</span>
    <span class="c1">#             return</span>
    <span class="c1">#     self.logger.info(f&quot;Successfully loaded {rel_path} from {commit_info}.&quot;)</span>
    <span class="c1">#     try:</span>
    <span class="c1">#         with io.BytesIO(targetfile.data_stream.read()) as f:</span>
    <span class="c1">#             df = load_tsv(f)</span>
    <span class="c1">#     except Exception:</span>
    <span class="c1">#         self.logger.error(f&quot;Parsing {rel_path} @ commit {commit_info} failed with the following error:\n{sys.exc_info()[1]}&quot;)</span>
    <span class="c1">#         return</span>
    <span class="c1">#     new_id = self._handle_path(new_path, key, skip_checks=True)</span>
    <span class="c1">#     self._parsed_tsv[new_id] = df</span>
    <span class="c1">#     self._dataframes[tsv_type][new_id] = df</span>
    <span class="c1">#     self._tsv_types[new_id] = tsv_type</span>
    <span class="c1">#     logger_cfg = dict(self.logger_cfg)</span>
    <span class="c1">#     logger_cfg[&#39;name&#39;] = self.logger_names[(key, i)]</span>
    <span class="c1">#     if tsv_id in self._annotations:</span>
    <span class="c1">#         anno_obj = self._annotations[tsv_id] # get Annotation object&#39;s settings from the existing one</span>
    <span class="c1">#         cols = anno_obj.cols</span>
    <span class="c1">#         infer_types = anno_obj.regex_dict</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         cols = dict(label=&#39;label&#39;)</span>
    <span class="c1">#         infer_types = None</span>
    <span class="c1">#     self._annotations[new_id] = Annotations(df=df, cols=cols, infer_types=infer_types,</span>
    <span class="c1">#                                         **logger_cfg)</span>
    <span class="c1">#     self.logger.debug(</span>
    <span class="c1">#         f&quot;{rel_path} successfully parsed from commit {short_sha}.&quot;)</span>
    <span class="c1">#     return new_id</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1"># def pieces(self, parsed_only=False):</span>
    <span class="c1">#     pieces_dfs = [self[k].pieces(parsed_only=parsed_only) for k in self.keys()]</span>
    <span class="c1">#     result = pd.concat(pieces_dfs, keys=self.keys())</span>
    <span class="c1">#     result.index.names = [&#39;key&#39;, &#39;metadata_row&#39;]</span>
    <span class="c1">#     return result</span>

    <span class="c1">#</span>
    <span class="c1"># def store_scores(self, keys=None, ids=None, root_dir=None, folder=&#39;.&#39;, suffix=&#39;&#39;, overwrite=False, simulate=False):</span>
    <span class="c1">#     &quot;&quot;&quot; Stores the parsed MuseScore files in their current state, e.g. after detaching or attaching annotations.</span>
    <span class="c1">#</span>
    <span class="c1">#     Parameters</span>
    <span class="c1">#     ----------</span>
    <span class="c1">#     keys : :obj:`str` or :obj:`~collections.abc.Collection`, optional</span>
    <span class="c1">#         Key(s) for which to count file extensions.  By default, all keys are selected.</span>
    <span class="c1">#     ids : :obj:`~collections.abc.Collection`</span>
    <span class="c1">#         If you pass a collection of IDs, ``keys`` is ignored and only the selected extensions are counted.</span>
    <span class="c1">#     root_dir : :obj:`str`, optional</span>
    <span class="c1">#         Defaults to None, meaning that the original root directory is used that was added to the Parse object.</span>
    <span class="c1">#         Otherwise, pass a directory to rebuild the original substructure. If ``folder`` is an absolute path,</span>
    <span class="c1">#         ``root_dir`` is ignored.</span>
    <span class="c1">#     folder : :obj:`str`</span>
    <span class="c1">#         Where to store the file. Can be relative to ``root_dir`` or absolute, in which case ``root_dir`` is ignored.</span>
    <span class="c1">#         If ``folder`` is relative, the behaviour depends on whether it starts with a dot ``.`` or not: If it does,</span>
    <span class="c1">#         the folder is created at every end point of the relative tree structure under ``root_dir``. If it doesn&#39;t,</span>
    <span class="c1">#         it is created only once, relative to ``root_dir``, and the relative tree structure is build below.</span>
    <span class="c1">#     suffix : :obj:`str`, optional</span>
    <span class="c1">#         Suffix to append to the original file name.</span>
    <span class="c1">#     overwrite : :obj:`bool`, optional</span>
    <span class="c1">#         Pass True to overwrite existing files.</span>
    <span class="c1">#     simulate : :obj:`bool`, optional</span>
    <span class="c1">#         Pass True if no files are to be written.</span>
    <span class="c1">#</span>
    <span class="c1">#     Returns</span>
    <span class="c1">#     -------</span>
    <span class="c1">#</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     if ids is None:</span>
    <span class="c1">#         ids = [id for id in self._iterids(keys) if id in self._parsed_mscx]</span>
    <span class="c1">#     paths = []</span>
    <span class="c1">#     for key, i in ids:</span>
    <span class="c1">#         new_path = self._store_scores(key=key, i=i, folder=folder, suffix=suffix, root_dir=root_dir, overwrite=overwrite, simulate=simulate)</span>
    <span class="c1">#         if new_path is not None:</span>
    <span class="c1">#             if new_path in paths:</span>
    <span class="c1">#                 modus = &#39;would have&#39; if simulate else &#39;has&#39;</span>
    <span class="c1">#                 self.logger.info(f&quot;The score at {new_path} {modus} been overwritten.&quot;)</span>
    <span class="c1">#             else:</span>
    <span class="c1">#                 paths.append(new_path)</span>
    <span class="c1">#     if simulate:</span>
    <span class="c1">#         return list(set(paths))</span>
    <span class="c1">#</span>
    <span class="c1">#</span>

    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1"># def _collect_annotations_objects_references(self, keys=None, ids=None):</span>
    <span class="c1">#     &quot;&quot;&quot; Updates the dictionary self._annotations with all parsed Scores that have labels attached (or not any more). &quot;&quot;&quot;</span>
    <span class="c1">#     if ids is None:</span>
    <span class="c1">#         ids = list(self._iterids(keys, only_parsed_mscx=True))</span>
    <span class="c1">#     updated = {}</span>
    <span class="c1">#     for id in ids:</span>
    <span class="c1">#         if id in self._parsed_mscx:</span>
    <span class="c1">#             score = self._parsed_mscx[id]</span>
    <span class="c1">#             if score is not None:</span>
    <span class="c1">#                 if &#39;annotations&#39; in score:</span>
    <span class="c1">#                     updated[id] = score.annotations</span>
    <span class="c1">#                 elif id in self._annotations:</span>
    <span class="c1">#                     del (self._annotations[id])</span>
    <span class="c1">#             else:</span>
    <span class="c1">#                 del (self._parsed_mscx[id])</span>
    <span class="c1">#     self._annotations.update(updated)</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1"># def _iterids(self, keys=None, only_parsed_mscx=False, only_parsed_tsv=False, only_attached_annotations=False, only_detached_annotations=False):</span>
    <span class="c1">#     &quot;&quot;&quot;Iterator through IDs for a given set of keys.</span>
    <span class="c1">#</span>
    <span class="c1">#     Parameters</span>
    <span class="c1">#     ----------</span>
    <span class="c1">#     keys</span>
    <span class="c1">#     only_parsed_mscx</span>
    <span class="c1">#     only_attached_annotations</span>
    <span class="c1">#     only_detached_annotations</span>
    <span class="c1">#</span>
    <span class="c1">#     Yields</span>
    <span class="c1">#     ------</span>
    <span class="c1">#     :obj:`tuple`</span>
    <span class="c1">#         (str, int)</span>
    <span class="c1">#</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     keys = self._treat_key_param(keys)</span>
    <span class="c1">#     for key in sorted(keys):</span>
    <span class="c1">#         for id in make_id_tuples(key, len(self.fnames[key])):</span>
    <span class="c1">#             if only_parsed_mscx  or only_attached_annotations or only_detached_annotations:</span>
    <span class="c1">#                 if id not in self._parsed_mscx:</span>
    <span class="c1">#                     continue</span>
    <span class="c1">#                 if only_attached_annotations:</span>
    <span class="c1">#                     if &#39;annotations&#39; in self._parsed_mscx[id]:</span>
    <span class="c1">#                         pass</span>
    <span class="c1">#                     else:</span>
    <span class="c1">#                         continue</span>
    <span class="c1">#                 elif only_detached_annotations:</span>
    <span class="c1">#                     if self._parsed_mscx[id].has_detached_annotations:</span>
    <span class="c1">#                         pass</span>
    <span class="c1">#                     else:</span>
    <span class="c1">#                         continue</span>
    <span class="c1">#             elif only_parsed_tsv:</span>
    <span class="c1">#                 if id in self._parsed_tsv:</span>
    <span class="c1">#                     pass</span>
    <span class="c1">#                 else:</span>
    <span class="c1">#                     continue</span>
    <span class="c1">#</span>
    <span class="c1">#             yield id</span>
    <span class="c1">#</span>
    <span class="c1"># def _iter_subdir_selectors(self, keys=None, ids=None):</span>
    <span class="c1">#     &quot;&quot;&quot; Iterate through the specified ids grouped by subdirs.</span>
    <span class="c1">#</span>
    <span class="c1">#     Yields</span>
    <span class="c1">#     ------</span>
    <span class="c1">#     :obj:`tuple`</span>
    <span class="c1">#         (key: str, subdir: str, ixs: list) tuples. IDs can be created by combining key with each i in ixs.</span>
    <span class="c1">#         The yielded ``ixs`` are typically used as parameter for ``.utils.iter_selection``.</span>
    <span class="c1">#</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     grouped_ids = self._make_grouped_ids(keys, ids)</span>
    <span class="c1">#     for k, ixs in grouped_ids.items():</span>
    <span class="c1">#         subdirs = self.subdirs[k]</span>
    <span class="c1">#         for subdir in sorted(set(iter_selection(subdirs, ixs))):</span>
    <span class="c1">#             yield k, subdir, [i for i in ixs if subdirs[i] == subdir]</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1"># def _parse(self, key, i, logger_cfg={}, labels_cfg={}, read_only=False):</span>
    <span class="c1">#     &quot;&quot;&quot;Performs a single parse and returns the resulting Score object or None.&quot;&quot;&quot;</span>
    <span class="c1">#     path = self.full_paths[key][i]</span>
    <span class="c1">#     file = self.files[key][i]</span>
    <span class="c1">#     self.logger.debug(f&quot;Attempting to parse {file}&quot;)</span>
    <span class="c1">#     try:</span>
    <span class="c1">#         logger_cfg[&#39;name&#39;] = self.logger_names[(key, i)]</span>
    <span class="c1">#         score = Score(path, read_only=read_only, labels_cfg=labels_cfg, logger_cfg=logger_cfg, ms=self.ms)</span>
    <span class="c1">#         if score is None:</span>
    <span class="c1">#             self.logger.debug(f&quot;Encountered errors when parsing {file}&quot;)</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             self.logger.debug(f&quot;Successfully parsed {file}&quot;)</span>
    <span class="c1">#         return score</span>
    <span class="c1">#     except (KeyboardInterrupt, SystemExit):</span>
    <span class="c1">#         self.logger.info(&quot;Process aborted.&quot;)</span>
    <span class="c1">#         raise</span>
    <span class="c1">#     except:</span>
    <span class="c1">#         self.logger.error(f&quot;Unable to parse {path} due to the following exception:\n&quot; + traceback.format_exc())</span>
    <span class="c1">#         return None</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1"># def _score_ids(self, keys=None, score_extensions=None, native=True, convertible=True, opposite=False):</span>
    <span class="c1">#     &quot;&quot;&quot; Return IDs of all detected scores with particular file extensions, or all others if ``opposite==True``.</span>
    <span class="c1">#</span>
    <span class="c1">#     Parameters</span>
    <span class="c1">#     ----------</span>
    <span class="c1">#     keys : :obj:`str` or :obj:`collections.abc.Iterable`, optional</span>
    <span class="c1">#         Only get IDs for particular keys.</span>
    <span class="c1">#     score_extensions : :obj:`collections.abc.Collection`, optional</span>
    <span class="c1">#         Get IDs for files with the given extensions (each starting with a dot). If this parameter is defined,</span>
    <span class="c1">#         ``native```and ``convertible`` are being ignored.</span>
    <span class="c1">#     native : :obj:`bool`, optional</span>
    <span class="c1">#         If ``score_extensions`` is not set, ``native=True`` selects all scores that ms3 can parse without using</span>
    <span class="c1">#         a MuseScore 3 executable.</span>
    <span class="c1">#     convertible : :obj:`bool`, optional</span>
    <span class="c1">#         If ``score_extensions`` is not set, ``convertible=True`` selects all scores that ms3 can parse as long as</span>
    <span class="c1">#         a MuseScore 3 executable is defined.</span>
    <span class="c1">#     opposite : :obj:`bool`, optional</span>
    <span class="c1">#         Pass True if you want to get the IDs of all the scores that do NOT have the specified extensions.</span>
    <span class="c1">#</span>
    <span class="c1">#     Returns</span>
    <span class="c1">#     -------</span>
    <span class="c1">#     :obj:`list`</span>
    <span class="c1">#         A list of IDs.</span>
    <span class="c1">#</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     if score_extensions is None:</span>
    <span class="c1">#         score_extensions = []</span>
    <span class="c1">#         if native:</span>
    <span class="c1">#             score_extensions.extend(Score.native_formats)</span>
    <span class="c1">#         if convertible:</span>
    <span class="c1">#             score_extensions.extend(Score.convertible_formats)</span>
    <span class="c1">#     if opposite:</span>
    <span class="c1">#         return [(k, i) for k, i in self._iterids(keys) if self.fexts[k][i][1:].lower() not in score_extensions]</span>
    <span class="c1">#     return [(k, i) for k, i in self._iterids(keys) if self.fexts[k][i][1:].lower() in score_extensions]</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1"># def _store_scores(self, key, i, folder, suffix=&#39;&#39;, root_dir=None, overwrite=False, simulate=False):</span>
    <span class="c1">#     &quot;&quot;&quot; Creates a MuseScore 3 file from the Score object at the given ID (key, i).</span>
    <span class="c1">#</span>
    <span class="c1">#     Parameters</span>
    <span class="c1">#     ----------</span>
    <span class="c1">#     key, i : (:obj:`str`, :obj:`int`)</span>
    <span class="c1">#         ID from which to construct the new path and filename.</span>
    <span class="c1">#     root_dir : :obj:`str`, optional</span>
    <span class="c1">#         Defaults to None, meaning that the original root directory is used that was added to the Parse object.</span>
    <span class="c1">#         Otherwise, pass a directory to rebuild the original substructure. If ``folder`` is an absolute path,</span>
    <span class="c1">#         ``root_dir`` is ignored.</span>
    <span class="c1">#     folder : :obj:`str`</span>
    <span class="c1">#         Where to store the file. Can be relative to ``root_dir`` or absolute, in which case ``root_dir`` is ignored.</span>
    <span class="c1">#         If ``folder`` is relative, the behaviour depends on whether it starts with a dot ``.`` or not: If it does,</span>
    <span class="c1">#         the folder is created at every end point of the relative tree structure under ``root_dir``. If it doesn&#39;t,</span>
    <span class="c1">#         it is created only once, relative to ``root_dir``, and the relative tree structure is build below.</span>
    <span class="c1">#     suffix : :obj:`str`, optional</span>
    <span class="c1">#         Suffix to append to the original file name.</span>
    <span class="c1">#     overwrite : :obj:`bool`, optional</span>
    <span class="c1">#         Pass True to overwrite existing files.</span>
    <span class="c1">#     simulate : :obj:`bool`, optional</span>
    <span class="c1">#         Pass True if no files are to be written.</span>
    <span class="c1">#</span>
    <span class="c1">#     Returns</span>
    <span class="c1">#     -------</span>
    <span class="c1">#     :obj:`str`</span>
    <span class="c1">#         Path of the stored file.</span>
    <span class="c1">#</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#</span>
    <span class="c1">#     id = (key, i)</span>
    <span class="c1">#     logger = self.id_logger(id)</span>
    <span class="c1">#     fname = self.fnames[key][i]</span>
    <span class="c1">#</span>
    <span class="c1">#     if id not in self._parsed_mscx:</span>
    <span class="c1">#         logger.error(f&quot;No Score object found. Call parse_scores() first.&quot;)</span>
    <span class="c1">#         return</span>
    <span class="c1">#     path = self._calculate_path(key=key, i=i, root_dir=root_dir, folder=folder)</span>
    <span class="c1">#     if path is None:</span>
    <span class="c1">#         return</span>
    <span class="c1">#</span>
    <span class="c1">#     fname = fname + suffix + &#39;.mscx&#39;</span>
    <span class="c1">#     file_path = os.path.join(path, fname)</span>
    <span class="c1">#     if os.path.isfile(file_path):</span>
    <span class="c1">#         if simulate:</span>
    <span class="c1">#             if overwrite:</span>
    <span class="c1">#                 logger.warning(f&quot;Would have overwritten {file_path}.&quot;)</span>
    <span class="c1">#                 return</span>
    <span class="c1">#             logger.warning(f&quot;Would have skipped {file_path}.&quot;)</span>
    <span class="c1">#             return</span>
    <span class="c1">#         elif not overwrite:</span>
    <span class="c1">#             logger.warning(f&quot;Skipped {file_path}.&quot;)</span>
    <span class="c1">#             return</span>
    <span class="c1">#     if simulate:</span>
    <span class="c1">#         logger.debug(f&quot;Would have written score to {file_path}.&quot;)</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         os.makedirs(path, exist_ok=True)</span>
    <span class="c1">#         self._parsed_mscx[id].store_scores(file_path)</span>
    <span class="c1">#         logger.debug(f&quot;Score written to {file_path}.&quot;)</span>
    <span class="c1">#</span>
    <span class="c1">#     return file_path</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1"># def _store_tsv(self, df, key, i, folder, suffix=&#39;&#39;, root_dir=None, what=&#39;DataFrame&#39;, simulate=False):</span>
    <span class="c1">#     &quot;&quot;&quot; Stores a given DataFrame by constructing path and file name from a loaded file based on the arguments.</span>
    <span class="c1">#</span>
    <span class="c1">#     Parameters</span>
    <span class="c1">#     ----------</span>
    <span class="c1">#     df : :obj:`pandas.DataFrame`</span>
    <span class="c1">#         DataFrame to store as a TSV.</span>
    <span class="c1">#     key, i : (:obj:`str`, :obj:`int`)</span>
    <span class="c1">#         ID from which to construct the new path and filename.</span>
    <span class="c1">#     folder, root_dir : :obj:`str`</span>
    <span class="c1">#         Parameters passed to :py:meth:`_calculate_path`.</span>
    <span class="c1">#     suffix : :obj:`str`, optional</span>
    <span class="c1">#         Suffix to append to the original file name.</span>
    <span class="c1">#     what : :obj:`str`, optional</span>
    <span class="c1">#         Descriptor, what the DataFrame contains for more informative log message.</span>
    <span class="c1">#     simulate : :obj:`bool`, optional</span>
    <span class="c1">#         Pass True if no files are to be written.</span>
    <span class="c1">#</span>
    <span class="c1">#     Returns</span>
    <span class="c1">#     -------</span>
    <span class="c1">#     :obj:`str`</span>
    <span class="c1">#         Path of the stored file.</span>
    <span class="c1">#</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     tsv_logger = self.id_logger((key, i))</span>
    <span class="c1">#</span>
    <span class="c1">#     if df is None:</span>
    <span class="c1">#         tsv_logger.debug(f&quot;No DataFrame for {what}.&quot;)</span>
    <span class="c1">#         return</span>
    <span class="c1">#     path = self._calculate_path(key=key, i=i, root_dir=root_dir, folder=folder)</span>
    <span class="c1">#     if path is None:</span>
    <span class="c1">#         return</span>
    <span class="c1">#</span>
    <span class="c1">#     fname = self.fnames[key][i] + suffix + &quot;.tsv&quot;</span>
    <span class="c1">#     file_path = os.path.join(path, fname)</span>
    <span class="c1">#     if simulate:</span>
    <span class="c1">#         tsv_logger.debug(f&quot;Would have written {what} to {file_path}.&quot;)</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         tsv_logger.debug(f&quot;Writing {what} to {file_path}.&quot;)</span>
    <span class="c1">#         write_tsv(df, file_path, logger=tsv_logger)</span>
    <span class="c1">#     return file_path</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1"># def _treat_key_param(self, keys):</span>
    <span class="c1">#     if keys is None:</span>
    <span class="c1">#         keys = list(self.full_paths.keys())</span>
    <span class="c1">#     elif isinstance(keys, str):</span>
    <span class="c1">#         keys = [keys]</span>
    <span class="c1">#     return [k for k in sorted(set(keys)) if k in self.files]</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1"># def _treat_harmony_layer_param(self, harmony_layer):</span>
    <span class="c1">#     if harmony_layer is None:</span>
    <span class="c1">#         return None</span>
    <span class="c1">#     all_types = {str(k): k for k in self.count_labels().keys()}</span>
    <span class="c1">#     if isinstance(harmony_layer, int) or isinstance(harmony_layer, str):</span>
    <span class="c1">#         harmony_layer = [harmony_layer]</span>
    <span class="c1">#     lt = [str(t) for t in harmony_layer]</span>
    <span class="c1">#     def matches_any_type(user_input):</span>
    <span class="c1">#         return any(True for t in all_types if user_input in t)</span>
    <span class="c1">#     def get_matches(user_input):</span>
    <span class="c1">#         return [t for t in all_types if user_input in t]</span>
    <span class="c1">#</span>
    <span class="c1">#     not_found = [t for t in lt if not matches_any_type(t)]</span>
    <span class="c1">#     if len(not_found) &gt; 0:</span>
    <span class="c1">#         plural = len(not_found) &gt; 1</span>
    <span class="c1">#         plural_s = &#39;s&#39; if plural else &#39;&#39;</span>
    <span class="c1">#         self.logger.warning(</span>
    <span class="c1">#             f&quot;No labels found with {&#39;these&#39; if plural else &#39;this&#39;} label{plural_s} harmony_layer{plural_s}: {&#39;, &#39;.join(not_found)}&quot;)</span>
    <span class="c1">#     return [all_types[t] for user_input in lt for t in get_matches(user_input)]</span>
    <span class="c1">#</span>
    <span class="c1"># def update_metadata(self, allow_suffix=False):</span>
    <span class="c1">#     &quot;&quot;&quot;Uses all parsed metadata TSVs to update the information in the corresponding parsed MSCX files and returns</span>
    <span class="c1">#     the IDs of those that have been changed.</span>
    <span class="c1">#</span>
    <span class="c1">#     Parameters</span>
    <span class="c1">#     ----------</span>
    <span class="c1">#     allow_suffix : :obj:`bool`, optional</span>
    <span class="c1">#         If set to True, this would also update the metadata for currently parsed MuseScore files</span>
    <span class="c1">#         corresponding to the columns &#39;rel_paths&#39; and &#39;fnames&#39; + [ANY SUFFIX]. For example,</span>
    <span class="c1">#         the row (&#39;MS3&#39;, &#39;bwv846&#39;) would also update the metadata of &#39;MS3/bwv846_reviewed.mscx&#39;.</span>
    <span class="c1">#</span>
    <span class="c1">#     Returns</span>
    <span class="c1">#     -------</span>
    <span class="c1">#     :obj:`list`</span>
    <span class="c1">#         IDs of the parsed MuseScore files whose metadata has been updated.</span>
    <span class="c1">#     &quot;&quot;&quot;</span>
    <span class="c1">#     metadata_dfs = self.metadata_tsv()</span>
    <span class="c1">#     if len(metadata_dfs) &gt; 0:</span>
    <span class="c1">#         metadata = pd.concat(metadata_dfs.values(), keys=metadata_dfs.keys())</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         metadata = self._metadata</span>
    <span class="c1">#     if len(metadata) == 0:</span>
    <span class="c1">#         self.logger.debug(&quot;No parsed metadata found.&quot;)</span>
    <span class="c1">#         return</span>
    <span class="c1">#     old = metadata</span>
    <span class="c1">#     if old.index.names != [&#39;rel_paths&#39;, &#39;fnames&#39;]:</span>
    <span class="c1">#         try:</span>
    <span class="c1">#             old = old.set_index([&#39;rel_paths&#39;, &#39;fnames&#39;])</span>
    <span class="c1">#         except KeyError:</span>
    <span class="c1">#             self.logger.warning(f&quot;Parsed metadata do not contain the columns &#39;rel_paths&#39; and &#39;fnames&#39; &quot;</span>
    <span class="c1">#                                 f&quot;needed to match information on identical files.&quot;)</span>
    <span class="c1">#             return []</span>
    <span class="c1">#     new = self.metadata(from_tsv=False).set_index([&#39;rel_paths&#39;, &#39;fnames&#39;])</span>
    <span class="c1">#     excluded_cols = [&#39;ambitus&#39;, &#39;annotated_key&#39;, &#39;KeySig&#39;, &#39;label_count&#39;, &#39;last_mc&#39;, &#39;last_mn&#39;, &#39;musescore&#39;,</span>
    <span class="c1">#                      &#39;TimeSig&#39;, &#39;length_qb&#39;, &#39;length_qb_unfolded&#39;, &#39;all_notes_qb&#39;, &#39;n_onsets&#39;, &#39;n_onset_positions&#39;]</span>
    <span class="c1">#     old_cols = sorted([c for c in old.columns if c not in excluded_cols and c[:5] != &#39;staff&#39;])</span>
    <span class="c1">#</span>
    <span class="c1">#     parsed = old.index.map(lambda i: i in new.index)</span>
    <span class="c1">#     relevant = old.loc[parsed, old_cols]</span>
    <span class="c1">#     updates = defaultdict(dict)</span>
    <span class="c1">#     for i, row in relevant.iterrows():</span>
    <span class="c1">#         new_row = new.loc[i]</span>
    <span class="c1">#         for j, val in row[row.notna()].iteritems():</span>
    <span class="c1">#             val = str(val)</span>
    <span class="c1">#             if j not in new_row or str(new_row[j]) != val:</span>
    <span class="c1">#                 updates[i][j] = val</span>
    <span class="c1">#</span>
    <span class="c1">#     l = len(updates)</span>
    <span class="c1">#     ids = []</span>
    <span class="c1">#     if l &gt; 0:</span>
    <span class="c1">#         for (rel_path, fname), new_dict in updates.items():</span>
    <span class="c1">#             matches = self.fname2ids(fname=fname, rel_path=rel_path, allow_suffix=allow_suffix)</span>
    <span class="c1">#             match_ids = [id for id in matches.keys() if id in self._parsed_mscx]</span>
    <span class="c1">#             n_files_to_update = len(match_ids)</span>
    <span class="c1">#             if n_files_to_update == 0:</span>
    <span class="c1">#                 self.logger.debug(</span>
    <span class="c1">#                     f&quot;rel_path={rel_path}, fname={fname} does not correspond to a currently parsed MuseScore file.&quot;)</span>
    <span class="c1">#                 continue</span>
    <span class="c1">#             for id in match_ids:</span>
    <span class="c1">#                 for name, val in new_dict.items():</span>
    <span class="c1">#                     self._parsed_mscx[id].mscx.parsed.metatags[name] = val</span>
    <span class="c1">#                 self._parsed_mscx[id].mscx.parsed.update_metadata()</span>
    <span class="c1">#                 self.id_logger(id).debug(f&quot;Updated with {new_dict}&quot;)</span>
    <span class="c1">#                 ids.append(id)</span>
    <span class="c1">#</span>
    <span class="c1">#         self.logger.info(f&quot;{l} files updated.&quot;)</span>
    <span class="c1">#     else:</span>
    <span class="c1">#         self.logger.info(&quot;Nothing to update.&quot;)</span>
    <span class="c1">#     return ids</span>
    <span class="c1">#</span>
    <span class="c1">#</span>
    <span class="c1"># def __getstate__(self):</span>
    <span class="c1">#     &quot;&quot;&quot; Override the method of superclass &quot;&quot;&quot;</span>
    <span class="c1">#     return self.__dict__</span>




    <span class="k">def</span> <span class="fm">__getitem__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">item</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Corpus</span><span class="p">:</span>
        <span class="k">if</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">str</span><span class="p">):</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_corpus</span><span class="p">(</span><span class="n">item</span><span class="p">)</span>
        <span class="k">elif</span> <span class="nb">isinstance</span><span class="p">(</span><span class="n">item</span><span class="p">,</span> <span class="nb">tuple</span><span class="p">):</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">1</span><span class="p">:</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_corpus</span><span class="p">(</span><span class="n">item</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>
            <span class="k">if</span> <span class="nb">len</span><span class="p">(</span><span class="n">item</span><span class="p">)</span> <span class="o">==</span> <span class="mi">2</span><span class="p">:</span>
                <span class="n">corpus_name</span><span class="p">,</span> <span class="n">fname_or_ix</span> <span class="o">=</span> <span class="n">item</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_corpus</span><span class="p">(</span><span class="n">corpus_name</span><span class="p">)[</span><span class="n">fname_or_ix</span><span class="p">]</span>
            <span class="n">corpus_name</span><span class="p">,</span> <span class="o">*</span><span class="n">remainder</span> <span class="o">=</span> <span class="n">item</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_corpus</span><span class="p">(</span><span class="n">corpus_name</span><span class="p">)[</span><span class="nb">tuple</span><span class="p">(</span><span class="n">remainder</span><span class="p">)]</span>

<div class="viewcode-block" id="Parse.__iter__"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.__iter__">[docs]</a>    <span class="k">def</span> <span class="fm">__iter__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Iterator</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Corpus</span><span class="p">]]:</span>
        <span class="sd">&quot;&quot;&quot;  Iterate through all (corpus_name, Corpus) tuples, regardless of any Views.</span>

<span class="sd">        Yields: (corpus_name, Corpus) tuples</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">yield from</span> <span class="bp">self</span><span class="o">.</span><span class="n">corpus_objects</span><span class="o">.</span><span class="n">items</span><span class="p">()</span></div>


<div class="viewcode-block" id="Parse.__repr__"><a class="viewcode-back" href="../../reference.html#ms3.parse.Parse.__repr__">[docs]</a>    <span class="k">def</span> <span class="fm">__repr__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Show the :meth:`info` under the active view.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">info</span><span class="p">(</span><span class="n">return_str</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span></div></div>

    <span class="c1"># def _get_unambiguous_fnames_from_ids(self, score_ids, key):</span>
    <span class="c1">#</span>
    <span class="c1">#     file_info = [self.id2file_info[id] for id in score_ids]</span>
    <span class="c1">#     score_names = [F.fname for F in file_info]</span>
    <span class="c1">#     score_name_set = set(score_names)</span>
    <span class="c1">#     if len(score_names) == len(score_name_set):</span>
    <span class="c1">#         return dict(zip(score_names, score_ids))</span>
    <span class="c1">#     more_than_one = {name: [] for name, cnt in Counter(score_names).items() if cnt &gt; 1}</span>
    <span class="c1">#     result = {} # fname -&gt; score_id</span>
    <span class="c1">#     for F in file_info:</span>
    <span class="c1">#         if F.fname in more_than_one:</span>
    <span class="c1">#             more_than_one[F.fname].append(F)</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             result[F.fname] = F.id</span>
    <span class="c1">#     for name, files in more_than_one.items():</span>
    <span class="c1">#         choice_between_n = len(files)</span>
    <span class="c1">#         df = pd.DataFrame.from_dict({F.id: dict(subdir=F.subdir, fext=F.fext, subdir_len=len(F.subdir)) for F in files}, orient=&#39;index&#39;)</span>
    <span class="c1">#         self.logger.debug(f&quot;Trying to disambiguate between these {choice_between_n} with the same fname &#39;{name}&#39;:\n{df}&quot;)</span>
    <span class="c1">#         shortest_subdir_length = df.subdir_len.min()</span>
    <span class="c1">#         shortest_length_selector = (df.subdir_len == shortest_subdir_length)</span>
    <span class="c1">#         n_have_shortest_length = shortest_length_selector.sum()</span>
    <span class="c1">#         # checking if the shortest path contains only 1 file and pick that</span>
    <span class="c1">#         if n_have_shortest_length == 1:</span>
    <span class="c1">#             id = df.subdir_len.idxmin()</span>
    <span class="c1">#             picked = df.loc[id]</span>
    <span class="c1">#             self.logger.info(f&quot;In order to pick one from the {choice_between_n} scores with fname &#39;{name}&#39;, the one with the shortest subdir &#39;{picked.subdir}&#39; was selected.&quot;)</span>
    <span class="c1">#             result[name] = id</span>
    <span class="c1">#             continue</span>
    <span class="c1">#         # otherwise, check if there is only a single MSCX or otherwise MSCZ file and pick that</span>
    <span class="c1">#         fexts = df.fext.value_counts()</span>
    <span class="c1">#         if &#39;.mscx&#39; in fexts:</span>
    <span class="c1">#             if fexts[&#39;.mscx&#39;] == 1:</span>
    <span class="c1">#                 picked = df[df.fext == &#39;.mscx&#39;].iloc[0]</span>
    <span class="c1">#                 id = picked.name</span>
    <span class="c1">#                 self.logger.info(f&quot;In order to pick one from the {choice_between_n} scores with fname &#39;{name}&#39;, the one contained in &#39;{picked.subdir}&#39; was selected because it is the only &quot;</span>
    <span class="c1">#                                  f&quot;one in MSCX format.&quot;)</span>
    <span class="c1">#                 result[name] = id</span>
    <span class="c1">#                 continue</span>
    <span class="c1">#         elif &#39;.mscz&#39; in fexts and fexts[&#39;.mscz&#39;] == 1:</span>
    <span class="c1">#             picked = df[df.fext == &#39;.mscz&#39;].iloc[0]</span>
    <span class="c1">#             id = picked.name</span>
    <span class="c1">#             self.logger.info(</span>
    <span class="c1">#                 f&quot;In order to pick one from the {choice_between_n} scores with fname &#39;{name}&#39;, the one contained in &#39;{picked.subdir}&#39; was selected because it is the only &quot;</span>
    <span class="c1">#                 f&quot;one in MuseScore format.&quot;)</span>
    <span class="c1">#             result[name] = id</span>
    <span class="c1">#             continue</span>
    <span class="c1">#         # otherwise, check if the shortest path contains only a single MSCX or MSCZ file as a last resort</span>
    <span class="c1">#         if n_have_shortest_length &lt; choice_between_n:</span>
    <span class="c1">#             df = df[shortest_length_selector]</span>
    <span class="c1">#             self.logger.debug(f&quot;Picking those from the shortest subdir has reduced the choice to {n_have_shortest_length}:\n{df}.&quot;)</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             self.logger.warning(f&quot;Unable to pick one of the available scores for fname &#39;{name}&#39;, it will be disregarded until disambiguated:\n{df}&quot;)</span>
    <span class="c1">#             continue</span>
    <span class="c1">#         if &#39;.mscx&#39; in df.fext.values and fexts[&#39;.mscx&#39;] == 1:</span>
    <span class="c1">#             pick_ext = &#39;.mscx&#39;</span>
    <span class="c1">#         elif &#39;.mscz&#39; in df.fext.values and fexts[&#39;.mscz&#39;] == 1:</span>
    <span class="c1">#             pick_ext = &#39;.mscz&#39;</span>
    <span class="c1">#         else:</span>
    <span class="c1">#             self.logger.warning(f&quot;Unable to pick one of the available scores for fname &#39;{name}&#39;, it will be disregarded until disambiguated:\n{df}&quot;)</span>
    <span class="c1">#             continue</span>
    <span class="c1">#         picked = df[df.fext == pick_ext].iloc[0]</span>
    <span class="c1">#         id = picked.name</span>
    <span class="c1">#         self.logger.info(</span>
    <span class="c1">#             f&quot;In order to pick one from the {choice_between_n} scores with fname &#39;{name}&#39;, the &#39;{pick_ext}&#39; one contained in &#39;{picked.subdir}&#39; was selected because it is the only &quot;</span>
    <span class="c1">#             f&quot;one in that format contained in the shortest subdir.&quot;)</span>
    <span class="c1">#         result[name] = id</span>
    <span class="c1">#     return result</span>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">################################################# End of Parse() ########################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>


<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">################################################# End of View() ########################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">########################################################################################################################</span>
<span class="c1">#</span>
<span class="c1"># class PieceView(View):</span>
<span class="c1">#</span>
<span class="c1">#     def __init__(self,</span>
<span class="c1">#                  view: View,</span>
<span class="c1">#                  fname: str):</span>
<span class="c1">#         self.view = view  # parent View object</span>
<span class="c1">#         self.p = view.p</span>
<span class="c1">#         self.key = view.key</span>
<span class="c1">#         self.fname = fname</span>
<span class="c1">#         logger_cfg = self.p.logger_cfg</span>
<span class="c1">#         logger_cfg[&#39;name&#39;] = f&quot;{self.view.logger.name}.{self.fname}&quot;</span>
<span class="c1">#         super(Parse, self).__init__(subclass=&#39;Piece&#39;, logger_cfg=logger_cfg)  # initialize loggers</span>
<span class="c1">#         matches = view.detect_ids_by_fname(parsed_only=True, names=[fname])</span>
<span class="c1">#         if len(matches) != 1:</span>
<span class="c1">#             raise ValueError(f&quot;{len(matches)} fnames match {fname} for key {self.key}&quot;)</span>
<span class="c1">#         self.matches = matches[fname]</span>
<span class="c1">#         self.score_available = &#39;scores&#39; in self.matches</span>
<span class="c1">#         self.measures_available = self.score_available or &#39;measures&#39; in self.matches</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#</span>
<span class="c1">#     @lru_cache()</span>
<span class="c1">#     def get_dataframe(self, what: Literal[&#39;measures&#39;, &#39;notes&#39;, &#39;rests&#39;, &#39;labels&#39;, &#39;expanded&#39;, &#39;events&#39;, &#39;chords&#39;, &#39;metadata&#39;, &#39;form_labels&#39;],</span>
<span class="c1">#                       unfold: bool = False,</span>
<span class="c1">#                       quarterbeats: bool = False,</span>
<span class="c1">#                       interval_index: bool = False,</span>
<span class="c1">#                       disambiguation: str = &#39;auto&#39;,</span>
<span class="c1">#                       prefer_score: bool = True,</span>
<span class="c1">#                       return_file_info: bool = False) -&gt; pd.DataFrame:</span>
<span class="c1">#         &quot;&quot;&quot; Retrieves one DataFrame for the piece.</span>
<span class="c1">#</span>
<span class="c1">#         Args:</span>
<span class="c1">#             what: What kind of DataFrame to retrieve.</span>
<span class="c1">#             unfold: Pass True to unfold repeats.</span>
<span class="c1">#             quarterbeats:</span>
<span class="c1">#             interval_index:</span>
<span class="c1">#             disambiguation: In case several DataFrames are available in :attr:`.matches`, pass its disambiguation string.</span>
<span class="c1">#             prefer_score: By default, data from parsed scores is preferred to that from parsed TSVs. Pass False to prefer TSVs.</span>
<span class="c1">#             return_file_info: Pass True if the method should also return a :obj:`namedtuple` with information on the DataFrame</span>
<span class="c1">#                 being returned. It comes with the fields &quot;id&quot;, &quot;full_path&quot;, &quot;suffix&quot;, &quot;fext&quot;, &quot;subdir&quot;, &quot;i_str&quot; where the</span>
<span class="c1">#                 latter is the ID&#39;s second component as a string.</span>
<span class="c1">#</span>
<span class="c1">#         Returns:</span>
<span class="c1">#             The requested DataFrame if available and, if ``return_file_info`` is set to True, a namedtuple with information about its provenance.</span>
<span class="c1">#</span>
<span class="c1">#         Raises:</span>
<span class="c1">#             FileNotFoundError: If no DataFrame of the requested type is available</span>
<span class="c1">#         &quot;&quot;&quot;</span>
<span class="c1">#         available = list(self.p._dataframes.keys())</span>
<span class="c1">#         if what not in available:</span>
<span class="c1">#             raise ValueError(f&quot;what=&#39;{what}&#39; is an invalid argument. Pass one of {available}.&quot;)</span>
<span class="c1">#         if self.score_available and (prefer_score or what not in self.matches):</span>
<span class="c1">#             file_info = disambiguate(self.matches[&#39;scores&#39;], disambiguation=disambiguation)</span>
<span class="c1">#             score = self.p[file_info.id]</span>
<span class="c1">#             df = score.mscx.__getattribute__(what)()</span>
<span class="c1">#         elif what in self.matches:</span>
<span class="c1">#             file_info = disambiguate(self.matches[what], disambiguation=disambiguation)</span>
<span class="c1">#             df = self.p[file_info.id]</span>
<span class="c1">#         else:</span>
<span class="c1">#             raise FileNotFoundError(f&quot;No {what} available for {self.key} -&gt; {self.fname}&quot;)</span>
<span class="c1">#         if any((unfold, quarterbeats, interval_index)):</span>
<span class="c1">#             measures = self.get_dataframe(&#39;measures&#39;, prefer_score=prefer_score)</span>
<span class="c1">#             df = dfs2quarterbeats([df], measures, unfold=unfold, quarterbeats=quarterbeats,</span>
<span class="c1">#                                    interval_index=interval_index, logger=self.logger)[0]</span>
<span class="c1">#         if return_file_info:</span>
<span class="c1">#             return df, file_info</span>
<span class="c1">#         return df</span>
</pre></div>

            <div class="clearer"></div>
          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<div class="sphinx-toc sphinxglobaltoc">
<h3><a href="../../index.html">Table of Contents</a></h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../install.html">Installation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../quick.html">Quick Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../manual.html">Manual</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../reference.html">Developers' Reference</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../license.html">License</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../authors.html">Authors</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../changelog.html">Changelog</a></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" autocomplete="off" autocorrect="off" autocapitalize="off" spellcheck="false"/>
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script>document.getElementById('searchbox').style.display = "block"</script>
        </div>
      </div>
    
    
        <div class="sidebar-toggle-group no-js">
            
            <button class="sidebar-toggle" id="sidebar-hide" title="Hide the sidebar menu">
                 
                <span class="show-for-small">hide menu</span>
                
            </button>
            <button class="sidebar-toggle" id="sidebar-show" title="Show the sidebar menu">
                
                <span class="show-for-small">menu</span>
                <span class="hide-for-small">sidebar</span>
                 
            </button>
        </div>
    
      <div class="clearer"></div>
    </div>
    <div class="relbar-bottom">
        
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="../../genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="../../py-modindex.html" title="Python Module Index"
             >modules</a> &nbsp; &nbsp;</li>
    <li><a href="../../index.html">ms3 0.5.3.post0.dev88+g764fcd4.dirty documentation</a> &#187;</li>

          <li class="nav-item nav-item-1"><a href="../index.html" >Module code</a> &#187;</li>
        <li class="nav-item nav-item-this"><a href="">ms3.parse</a></li> 
      </ul>
    </div>
    </div>

    <div class="footer" role="contentinfo">
        &#169; Copyright 2020, johentsch.
      Created using <a href="https://www.sphinx-doc.org/">Sphinx</a> 5.1.1.
    </div>
    <!-- cloud_sptheme 1.4 -->
  </body>
</html>